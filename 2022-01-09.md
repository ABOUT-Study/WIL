# 1
## Stream 의 병렬 처리
Stream 은 Java 8 에 추가된 Lambda 활용할 수 있는 기술 중 하나로, 연속된 요소의 집합 입니다.   
기본적으로 순차처리 되지만, parallelStream() 을 통해 병렬 처리를 할 수 있습니다.

- 병렬처리
  - 병렬 처리(Parallel Operation)란 멀티 코어 환경에서 하나의 작업을 분할해 각각의 코어가 병렬적으로 처리하는 것이다.
  
- 동시성   
  - 멀티 작업을 위해 멀티 스레드가 번갈아가며 실행하는 성질이다.   
  - 싱글 코어 CPU를 이용한 멀티 작업은 병렬적으로 실행되는 것처럼 보이지만 실제로는 동시성 작업이다.
![1](https://user-images.githubusercontent.com/20812458/148556804-af0be8a8-a5cb-4742-9cff-55fe8d5c816c.png)

- 주의사항   
  1. 요소의 수가 많고 요소당 처리시간이 긴 경우
      - 병렬 처리는 스레드 풀을 생성하고 스레드를 생성하는 추가적인 비용이 발생한다. 때문에 요소의 수가 적다면 오히려 순차 처리가 빠를 수 있다.
      - 멀티 코어에서 데이터의 이동은 오버헤드가 크기때문에 데이터 전송 시간보다 오래 걸리는 작업만 병렬로 처리하는 것이 좋다.
  2. 스트림 소스의 종류
      - ArrayList나 배열은 인덱스로 요소를 관리해 분리가 쉽지만 LinkedList는 분할을 위해서는 모두 탐색을 해야 하기 때문에 느릴 수 있다.
  3. 코어(core)의 수
      - 만약 실행하는 프로세서가 싱글 코어라면 스레드의 수만 증가하고 동시성 작업으로 진행되기 때문에 오히려 성능이 하락한다.
  4. 병렬로 수행하기 어려운 스트림 모델
      - iterate()의 경우, 이전 연산의 결과가 스트림의 입력에 영향을 미친다. 때문에 이전 연산이 완료되어야 다음 스트림으로 넘어갈 수 있기 때문에 분할하기 어려워 성능이 오히려 하락한다.
  5. 박싱의 최소화
      - 박싱과 언박싱은 성능을 크게 하락시키기 때문에 기본형 스트림(IntStream, LongStream, DoubleStream)을 우선 사용해야한다.
   6. 순서에 의존하는 연산
      - 순서에 의존하는 연산은 스트림에서 수행하게 되면 많은 비용이 발생한다.
      - 순서가 중요하지 않다면 findFirst보다 findAny가 좋고, 단순 limit보다 unordered().limit이 더 효율적이다.

#2
## 포크/조인 프레임워크
병렬화할 수 있는 작업을 재귀적으로 서브 데이터로 분할한 다음 각각의 결과를 합쳐 전체 결과를 만들도록 해주는 프레임워크

- Recursive Task
  - 스레드 풀을 사용하기 위해서는 RecursiveTask<R>의 서브 클래스를 구현하면 된다. 여기서 R은 병렬화를 통해 연산된 결과이다. 
  ![2](https://user-images.githubusercontent.com/20812458/148566049-4df96366-d890-4214-98ec-b0fc07feb312.png)
  
- 주의점
    - join()메소드는 결과를 반환할 때까지 블록시키기 때문에 항상 두 서브 테스크를 시작한 뒤 호출해야 한다. 그렇지 않으면, 기존의 순차 스트림보다 느리게 된다
    - RecursiveTask 내에서는 ForkJoinPool의 invoke()를 사용하면 안되고 compute()나 fork()메소드를 호출해야 한다.
    - 분리된 서브테스크 중 한 작업에만 compute()작업을 호출해야 한다. 한 테스크는 같은 스레드를 재사용할 수 있어 오베헤드가 감소한다.
    - 병렬 계산은 디버깅이 어렵다. 다른 스레드에서 compute()를 호출하기 때문에 stack trace가 도움이 되지 않는다.
- 작업 훔치기
    - 만약 서브 테스크를 1000개 이상으로 분리하면 각각의 테스크에 CPU을 할당할 수 없어 낭비같아 보일 수 있다.   
      하지만 실제로는 가능한 많이 분할하는 것이 좋다.
 
  ![3](https://user-images.githubusercontent.com/20812458/148571665-92fc6c14-8aad-4bfc-aa30-fe185ecf5217.png)
      작업 훔치기(work stealing) 기법은 모든 스레드를 거의 공정하게 분할하게 된다.   
      각각의 스레드는 자신에게 할당된 테스크를 포함하는 이중 연결리스트를 참조하고, 작업이 끝날 때마다 큐의 헤드에서 다른 테스크를 가져와 작업을 처리한다.
      한 스레드는 다른 스레드보다 빠르게 작업을 처리하게 되면 다른 스레드 큐의 꼬리(tail)에서 작업을 훔쳐온다.
      모든 큐가 빌 때까지 과정을 반복하게 되는데 이 때문에 테스크의 크기를 작게 나누어야 스레드 간의 작업 부하를 비슷하게 유지할 수 있게 된다.

[출처] (https://velog.io/@hyune-c/Stream-%EC%9D%98-%EB%B3%91%EB%A0%AC-%EC%B2%98%EB%A6%AC%EB%9E%80)
[출처] (https://girawhale.tistory.com/131)
[출처] (https://runebook.dev/ko/docs/openjdk/java.base/java/util/concurrent/forkjointask#fork())
