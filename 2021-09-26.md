
# Docker
* #### 도커는 언제 쓰일까?
  * 새로운 PC를 구매했다면, 기존 PC에서 사용했던 프로그램과 설정을 세팅해야한다. 이와 같은 맥락으로 현업에서 새로운 서버를 구축할때는 개인 PC보다 더 많은 프로그램과 설정들을 세팅해줘야한다. 게다가 1개가 아니라 여러대의 서버를 구축해야한다면? 서버 하나에 들어가서 개발자가 일일히 세팅 해줘야한다면 너무 번거로운 작업일 것이다. 이때 도커를 사용한다.

* #### 도커를 한마디로 표현하면?
  * "필요한 것들은 미리 만들어 놓자! 그리고 그걸 불러와서 쓰자!"
  * 수평적인 확장에 매우 편함!

* #### 도커의 전반적인 프로세스
  1. 필요한 프로그램과 설정들을 도커파일로 만든다. 
  2. 도커파일을 통해 도커 image를 생성해서 버전관리가 되게한다. 
  3. 도커 image는 Docker HUB라는 곳에 저장된다. 
  4. 내가 필요할때마다 이 Image를 PC에 다운받아서설치할수 있다.

![image](https://user-images.githubusercontent.com/22884224/132627349-a5a7b4dd-c90a-4e40-a564-31e5fd0d7b08.png)
          
* #### 여러개의 Image를 하나의 PC에 설치하다가 충돌이 나면 어떻게 합니까?
  * 서버에서 내가 원하는 image를 설치할때 그 상태를 바로 설치하지 않는다. 해당 상태를 Container라는 독립된 가상공간에 만들고 설치한다. 그러면 image마다 Container는 따로따로 존재하기때문에 버전이 겹치거나 내가 원하지 않는 설정이 설치되는것을 피할 수 있다.  

[출처] https://tech.osci.kr/2020/03/03/91690167/   
[출처] https://www.youtube.com/watch?v=tPjpcsgxgWc

# Java빌드과정
![image](https://user-images.githubusercontent.com/22884224/132803126-d33cd8a5-0814-4678-ad9f-1b70193696d2.png)

* #### JVM이란?
   * JVM은 OS와 우리가 개발한 프로그램 사이에서 기계어 해석을 해주는 역할을 맡고있다. 그래서 Java가 어떤 OS에 설치되든 JVM에 의해 .java코드가 기계어로 해석 될 수 있다. 즉, 실행 가능하다.   

* #### 빌드 과정
  1. 개발자가 test.java코드를 작성한다.
  2. javac 컴파일러를 통해 test.java를 test.class파일로 컴파일한다. test.class 코드는 JVM만 이해할 수 있는 바이트 코드이다. 즉, 컴퓨터가 읽을 수 있는 기계어가 아니다. 
  3. 클래스 로더가 바이트 코드(test.class)를 JVM내에 로드한다. 
  4. 실행엔진(Execution Engine)에 의해 JVM 메모리에 올라온 바이트 코드들은 기계어로 해석되어 메모리상(Runtime Data Area)에 배치된다. 이 때 실행엔진은 인터프리터와 JIT Compiler를 사용해 바이트 코드를 해석한다. 
     - 인터프리터는 바이트코드를 한줄씩 읽어서 해석, 처리하기떄문에 명령어 하나씩 실행하는 속도가 빠르지만, 전체적인 코드에 대해선 실행속도가 느리다.
     - JIT Compiler는 자주 사용하는 코드를 캐싱하고 이후에 같은 코드가 나오면 캐싱된 것을 가져다 쓴다. 매번 기계어로 번역하는 interpreter 방식보다 빠르게 기계어로 번역할 수 있다. 하지만 코드 전체를 컴파일하기 때문에 인터프리팅하는 것보다 시간이 오래 걸리므로 한 번만 실행해도 되는 코드에 대해서는 인터프리팅하는 것이 유리하다.   
 
[출처] https://velog.io/@litien/JVM-%EA%B5%AC%EC%A1%B0   
[출처] https://velog.io/@woo00oo/%EC%9E%90%EB%B0%94-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EA%B3%BC%EC%A0%95   
[출처] https://aljjabaegi.tistory.com/387   

# DB캐싱전략
* #### aside cache(look aside cache, lazy loading) 전략
  * 이 전략은 클라이언트에서 데이터 요청이 오면 Cache에서 로딩하는 전략이다.   
 DB나 외부 API에 접근하기 전에 cache에 접근해서 Cache 요청 데이터가 존재하면 Cache데이터를 로딩,    
 존재하지않으면 DB나 외부API에 접근해서 데이터를 가져오고 Cache 저장한다.   
 보통 read가 많은 애플리케이션에서 사용한다.
  * 장점
    1) 요청받은 데이터만 캐시에 저장한다. 즉, 실제로 접근이 있는 데이터만 캐시에 담을 수 있다.
    2) 캐시미스가 발생했을때 치명적이지 않다. 실제데이터에 접근해서 데이터를 가져오면 되기때문에
  * 단점
    1) 캐시미스일 경우, 여러번의 프로세스를 거치기 때문에 지연시간이 증가한다.
    2) 데이터를 write할때 만약 캐시데이터가 존재하면 원본데이터만 write하고 캐시에는 업데이트하지않기때문에 DB와 캐시 데이터가 다를 수 있다.   즉, 동기화 문제가 생긴다. ( 캐시에 업데이트 되는 경우는 해당 데이터가 캐시에 존재하지 않을 경우 )    ⇒ TTL을 사용하면 데이터가 만료되기때문에, 자연스럽게 캐시미스를 일으켜 동기화문제 해결가능.
![Untitled](https://user-images.githubusercontent.com/22884224/134834056-bd2cd04b-4d55-402d-96d2-d5772626b625.png)

* #### write through 전략
  * write through전략은 데이터를 write 할때 DB와 캐시 동시에 업데이트하는 전략.
  * 장점
    1) 항상 DB와 캐시데이터가 동기화 된다.
  * 단점
    1) 사용하지않는 데이터도 캐시에 저장되기때문에 리소스가 낭비된다.     
    ⇒ TTL을 사용하면 write되지않는 데이트들은 만료되기 때문에리소스 낭비를 피할 수 있다.
    2) 데이터를 write할때마다 DB,  캐시 모두 업데이트하기때문에 지연시간이 증가한다.
![Untitled 2](https://user-images.githubusercontent.com/22884224/134834115-6db6717f-1224-43d8-84e1-a34ffd6818d2.png)

* #### write back (= write behind) 전략
  * 캐시에 데이터들을 저장하고 약간의 지연 후에 데이터들을 DB에 저장해서 쓰기 성능을 향상시킨다. 쓰기가 많은 작업에 적합하다.
  * 장점
    1) DB에 대한 전체 쓰기가 줄어들기때문에, 비용을 감소할 수 있다.
  * 단점 
    1) DB에 저장하기전에, 캐시에서 오류가 발생하면 데이터가 영구 소실 될 수 있다.
![Untitled3](https://user-images.githubusercontent.com/22884224/134834148-28c4887e-47e1-4bc2-87b1-764548186675.png)

[출처] https://wnsgml972.github.io/database/2020/12/13/Caching/   
[출처] https://meetup.toast.com/posts/225/

# 4
# JVM, JRE, JDK 차이점

* #### JVM(Java Virtual Muchine) : 자바 바이트코드를 실행할수 있는 주체이며, 자바 코드를 컴파일해서 얻은 바이트코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행해주는 역할을 한다.
* #### JRE(Java Runtime Enviroment): 자바로짠 소프트웨어가 컴파일 및 빌드까지 다된다음 이를 사용할 곳에 주어져서 실행이 될때 그 환경요소들로서 필요한것.
* #### JDK(Java Development Kit) : JRE와 더불어 자바 개발을 할때 필요로 하는, 자바코드를 컴파일할때 쓰는 javac, 필요한 jar파일을 묶어주는 JAR를 포함하게된다. 즉, 개발에 필요한 환경을 제공을 한다. 
Map, List 를 사용하기위하여 JRE를 다운받으면 rt.jar에 관련 class를 사용하는것과같이 널리쓰이는, 그리고 JVM에서 도는 라이브러리들을 JVM이랑 세트로 묶어서 사용할수있게 JRE이다. 
*JRE만 깔리면 자바로 작성한 프로그램을 돌릴수 있게 된다.
* JRE는 JVM을 포함하고 있다.
* 정리 : 자바를 실행만 하기위해서는 JRE만 설치해도 상관이없지만 자바를 개발하기위해서는 JDK를 설치하는게 좋다.
![JVM,JDK,JRE 차이점](https://user-images.githubusercontent.com/83939644/138581473-430ccd0d-9dfe-4383-a0c8-b519a85da163.png)

# 5
# 퍼사드(Facade) 패턴

* #### 흔히 많이사용하지만 패턴으로는 생소한 퍼사드 패턴은 여러 클래스의 객체들을
복합적으로 사용해야 하는 작업들을 통합하여 동작시킬수 있도록 제공하는 패턴으로 설명할수 있다.
![퍼사드패턴](https://user-images.githubusercontent.com/83939644/138581475-b99048d4-8623-4342-ac74-b203e356d870.png)
* #### 흔히 사용하는 메소드에 구현체를 만들어서 그 메소드를 호출하여 안에 세부 코드를 호출하는것을 의미한다.
 * 현재 위치를 얻는 예제 소스를 가지고 설명을 하면,
 * ①빨간색 : 현재 위치의 좌표를 가져온다.
 * ②파란색 : 인터넷에 연결해서  위치 좌표를가지고 주소를 받아온다.
 * ③노란색 : 주소를 Map에 담아 반환한다.
 * ④보라색: 위의 과정을 한번에 실행할수 있는 클래스와 메소드를 선언하면 사용자는 일련의 과정의 내용을 알필요없이 해당하는 결과를 가져올수있다.
 
 # 6
 # 온프레미스(On-premise)와 클라우드(Cloud)컴퓨팅 차이점
 * #### 온프레미스는 쉽게 자사에서 모든 하드웨어, 소프트웨어를 관리하는것을 말한다. 자사에 직접 자원과 모든 비용을 소모하여 구축하여 유지하는것을 뜻한다. 클라우드는 쉽게 소프트웨어와 하드웨어를 일부 빌려서 사용하는것을 말한다. 아마존 , 구글 등 일정 비용을 지불하여 자원을 사용하는것을 뜻한다.

![온프레미스](https://user-images.githubusercontent.com/83939644/138581474-55050215-a5ae-48e3-b033-b65446de3e22.png)
* #### 온프레미스와 클라우드 시스템의 가장 큰 차이점은 서비스를 제공함에 있어 사용하는 IT 자원을 누가 관리하느냐입니다. 온프레미스의 경우 서비스를 공급하는 서비스 제공자가 직접적으로 IT 자원을 관리하는 주체가 되고, 클라우드 시스템의 경우 서비스를 공급하는 제공자는 IT 자원을 사용할 뿐, 대부분의 IT 자원 관리는 클라우드 서비스 제공자에게 제공받습니다.
