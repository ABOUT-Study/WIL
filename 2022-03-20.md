# 1
## 대규모 데이터 처리의 어려운점
- 대규모 데이터는 어떤 점이 어려운가?
    - 메모리 내에서 계산할 수 없다.
        - 메모리 내에서 계산하게 된다면 성능이 빠르겠지만, 대규모 데이터들은 너무 많아서 메모리 내에서 계산할 수가 없다. 디스크에 두고 데이터를 검색해야한다.
- 메모리와 디스크의 속도차
    - 디스크는 메모리보다 훨씬 느리다. 10^5 ~ 10^6 정도 차이가 난다.
- 디스크가 늦는 이유
    1. 탐색 속도
        - 디스크는 물리적 구조로 이루어진 장치고 메모리는 전기적인 신호로 동작한다. 물리적인 구조는 한계가 있다.
        - 디스크는 데이터를 읽을 때 헤드의 이동, 디스크의 회전 등의 이유로 탐색 속도가 늦다.
        - 디스크의 느린다는 단점을 OS가 “비슷한 데이터를 한곳에 모아둬서 한번에 많이 읽게한다” 같은 기술로 커버해준다, 그래도 메모리보다 느리다.
    2. 전송 속도
        - 메모리와 디스크 모두  CPU와 버스로 연결되어있다.
        - 탐색한 데이터를 처리하기위해서는 결국엔 CPU로 보내야하는데 이 속도도 메모리가 훨씬 앞선다.
        - 요즘엔 물리적인 SSD가 나와서 탐색 속도는 빨라졌지만, 그래도 메모리에 비해선 훨씬 느리다.

[출처] 대규모 서비스를 지탱하는 기술(강의5)

# 2 
## 대규모 조정의 요소(CPU부하와 I/O부하)
- 규모조정, 확장성
    - 웹 서비스에서 성능을 높이는 일반적인 방법은 **스케일 아웃**이다. 고가의 하드웨어를 사는 스케일업보다 일반적인 성능의 하드웨어를 여러대 나열하는 것이 더 저렴하고 유연성이 크기 때문이다.
- CPU부하와 I/O부하
    - 우리가 서비스를 이용할때 사용되는 애플리케이션 서버는 기본적으로 **CPU부하만 소요**된다.
    - 하지만 서버는 결국 DB의 질의와 결과를 얻어내야하는데 이때는 **I/O부하**가 걸린다.
- CPU부하로 인한 확장, I/O부하로 인한 DB 확장
    - **애플리케이션 서버는 CPU부하만 걸리므로 분산(=스케일 아웃)이 간단하다.** 그 이유는 기본적으로 데이터를 분산해서 갖고 있는 것이 아니고, 어떤 요청이 들어오면 서버들이 동일하게 처리만 하면 되기 때문이다. 따라서 확장을 위해선 동일한 서버의 대수만 늘리면 되는데, 이는 로드밸런서가 해준다.
    - **반면에 I/O부하로 인한 DB서버 분산에는 문제가 있다.** DB를 여러개 확장하면 그 DB들간의 데이터를 어떻게 동기화 할 것인가에 대한 숙제가 생기기 때문이다.
- DB 확장성 확보의 어려움
    - 위에서 설명한 동기화 문제와 더불어 **DB는 디스크를 많이 사용하기때문에 이 또한 성능의 문제**가 될 수 도 있다.
    - 즉, 대규모 환경에서는 I/O 부하를 부담하고 있는 DB서버는 애초에 분산시키기도 어렵고, 디스크 I/O가 많이 발생할 수 있기때문에 더 어려워진다.
    
- 정리
    - CPU 부하의 규모조정은 간단하다
        - 같은 구성의 서버를 늘리고 로드밸런서로 분산
    - I/O 부하의 규모조정은 어렵다
        - DB 동기화와 디스크 접근에 대한 한계

[출처] 대규모 서비스를 지탱하는 기술(강의6)

# 3
## enum의 활용
- enum 이란
    -  우리가 흔히 상수를 정의할 때 final static string 과 같은 방식으로 상수를 정의를합니다. 하지만 이렇게 상수를 정의해서 코딩하는 경우 다양한 문제가 발생됩니다. 
        따라서 이러한 문제점들을 보완하기 위해 자바 1.5버전부터 새롭게 추가된 것이 바로 "Enum" 입니다.
        Enum은 열거형이라고 불리며, 서로 연관된 상수들의 집합을 의미합니다.
        기존에 상수를 정의하는 방법이였던 final static string 과 같이 문자열이나 숫자들을 나타내는 기본자료형의 값을 enum을 이용해서 같은 효과를 낼 수 있습니다.
        
- enum 장점
    - 코드가 단순해지며, 가독성이 좋습니다.
    - 인스턴스 생성과 상속을 방지하여 상수값의 타입안정성이 보장됩니다.
    - enum class를 사용해 새로운 상수들의 타입을 정의함으로 정의한 타입이외의 타입을 가진 데이터값을 컴파일시 체크한다.
    - 키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 알 수 있습니다.

- 기본 enum 예제
    - 요구사항
        - 스위치 상수를 만들어라. (ON과 OFF의 상태가 있다)    
  ```
    public enum Switch {
        ON,
        OFF;
    }
    
    ----
    
    public static void main(String[] args) {
        Switch.ON; // 이런식으로 사용 가능. DB에 Switch 데이터를 그대로 넣게되면 ON만 들어감
    }
  ```
  
- enum 활용
    - 요구사항
        - 재고의 개수와 재고의 상태에 따라 상품의 노출, 비노출을 결정하는 컨슈머가 있다.
        - 재고는 판매중, 재고소진, 판매중지의 상태를 갖는다.
        - 판매중일 상태일때는 재고의 개수와 상관없이 상품의 노출이 변경되면 안된다.
        - 재고소진일 상태일때는 재고의 상태가 0개가 아니면 상품의 노출이 ON 되어야 한다. 재고가 0이면 변견되면 안된다.
        - 판매중지일 상태일때는 재고의 개수와 상관없이 삼품의 노출이 OFF가 되어야 한다.
 
    ```
    
    @AllArgsConstructor
    public enum SkuStatus {
        ON_SALE("판매중",
            Collections.EMPTY_LIST
        ),
        PULL_OUT("재고소진",
            Arrays.asList(
                SkuStatuss.Display.Request.of(true)
            )
        ),
        STOP_SALE("판매중지",
            Collections.EMPTY_LIST
        );

        @Getter
        private final String description;
        private final List<Display.Request> displayOnValues;

        private boolean isDisplayPass(final Display.Request request) {
            if (this == ON_SALE) {
                return true;
            }
            
            if (!request.stockZero) {
                return false;
            }

            return true;
        }

        private boolean isDisplayOn(final Display.Request request) {
            return displayOnValues.contains(request);
        }

        public Display getDisplayBy(final Display.Request request) {
            if (isDisplayPass(request)) {
                return Display.PASS;
            }
            if (isDisplayOn(request)) {
                return Display.ON;
            }

            return Display.OFF;
        }


        @AllArgsConstructor
        public enum Display {
            ON("노출"),
            OFF("비노출"),
            PASS("변경없음"),
            NONE(Strings.EMPTY);

            private final String description;

            public boolean isDisplay() {
                return this == ON;
            }

            @AllArgsConstructor
            public static class Request {
                private static final List<Request> ALL_REQUESTS;

                private static final Request ALL_TRUE = new Request(true);
                private static final Request ALL_FALSE = new Request(false);

                static {
                    ALL_REQUESTS = Arrays.asList(ALL_TRUE, ALL_FALSE);
                }

                private final boolean stockZero;

                public static Request of(final boolean stockZero) {
                    return ALL_REQUESTS.stream()
                        .filter(request -> request.stockZero == stockZero)
                        .findFirst()
                        .get();
                }
            }
        }
    }
    
    ------
    
    public static class Sku {
    
        private SkuStatus skuStatus;
        private int stock;

        public SkuStatus.Display getSkuDisplay() {
            return skuStatus.getDisplayBy(SkuStatus.Display.Request.of(stock == 0, handling));
        }
    }
    
    ------
    // sns로 컨슈머 사용한다고 예를 들겠음.
    @SqsListener(value = "${sk-status}", deletionPolicy = ON_SUCCESS)
    public externalApiSkuStatus(Sku message) {
        
        ...
        
        SkuStatus.Display display = message.getSkuDisplay(); // 재고의 상태와 개수에 따른 상품의 Display가 정해진다.
        
        // display를 가지고 상품의 노출을 업데이트
        
    }
    
    
    ```
 

# 4

# 5

# 6

# 7

# 8

# 9
