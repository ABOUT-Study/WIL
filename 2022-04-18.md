# 1
## 동적 파라미터화 (Behavior Parameterization)

- 자주 바뀌는 요구사항에 효과적 대응
- 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미.

```
-- 어떤 기준으로 사과를 분류하는 메서드 (기존 방식)


public static List<Apple> filterApples
    (List<Apple> inventory, String color, int weight, boolean flag) {
        List<Apple> result = new ArrayList<>();
        for(Apple apple : inventory) {
            if((flag && apple.getColor().equals(color)) ||
                (!flag && apple.getWeight() > weight)) {
                    result.add(apple);
            }
        }
    return result;
}

List<Apple> greenApples = filterApples(inventory, "green", 0, true);
List<Apple> heavyApples = filterApples(inventory, "", 150, false);
```

- 기존방식 코드의 문제점
  - flag가 의미하는 것이 무엇인지 알 수 없다.
  - 확장 및 추가가 힘들다.
 
 - 위 문제를 단순화 하여 보면, 사과의 어떤 속성에 기초해서 불린값을 반환하는 메서드로 볼 수 있다.
    이러한 동작을 프레디케이트(Predicate)라고 한다.
    
```
▶ 조건에 따라 값을 결정하는 인터페이스 정의
public interface ApplePredicate {
 boolean test(Apple apple);
}

▶ 정의할 조건에 따른 버전별 Predicate 정의
public class AppleHeavyWeightPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return apple.getWeight() > 150;
    }
}

public class AppleGreenColorPredicate implements ApplePredicate {
    public boolean test(Apple apple) {
        return "green".equals(apple.getColor());
    }
}


▶ Predicate를 적용한 소스
public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) { 
    List<Apple> result = new ArrayList<>();
    for(Apple apple : inventory) {
        if(p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}

List<Apple> greenApple = filterApples(inventory, new AppleGreenColorPredicate());

  
  
▶ 익명 클래스를 사용하여 간소화 시키기

List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
    public boolean test(Apple apple) {
        return "red".equals(apple.getColor());
    }
});


▶ 람다식을 사용하여 더 간단하게 만들기

List<Apple> result = 
    filterApples(inventory, (Apple apple) -> 
        "red".equals(apple.getColor()));



▶ 제네릭을 통한 추상화 (확장성을 추가)

public interface Predicate<T> {
    boolean test(T t);
}

public static <T> List<T> filter(List<T> list, Predicate<T> p) {
    List<T> result = new ArrayList<>();
    for(T e : list) {
        if(p.test(e)) {
            result.add(e);
        }
    }
    return result;
}

List<Apple> redApples = filter(inventory, (Apple apple) ->
    "red".equals(apple.getColor()));
```
  
- 정리
  - 1. 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달한다.
  - 2. 동작 파라미터화를 이용하면 변화하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 있으며, 나중에 엔지니어링 비용을 줄일 수 있다.
  - 3. 코드 전달 기법을 이용하면 동작을 메서드의 인수로 전달할 수 있다. 하지만 자바8 이전에는 코드를 지저분하게 구현해야 했다. 익명 클래스로도 어느 정도 깔끔하게 만들 수 있지만 자바8에서는 인터페이스를 상속받아 여러 클래스를 구현해야 하는 수고를 없앨 수 있는 방법을 제공한다.
  - 4. 자바 API의 많은 메서드는 정렬, 스레드, GUI 처리 등을 포함한 다양한 동작으로 파라미터화할 수 있다.

# 2
## 리팩토링 
- 책을 읽으면서 나오는 규칙을 하나씩 정해가면서 그 규칙을 지키며 리팩토링을 진행한다.
- 리팩토링은 작은 기능부터 연습을 해간다.(처음부터 큰 기능에 적용을 하려 하면 겁이나고 어렵기 때문이다.)

[예시]   

<img width="844" alt="image" src="https://user-images.githubusercontent.com/20812458/163763539-6f6d0d2a-d209-4d27-bd12-a51bd6934655.png">   

<img width="834" alt="image" src="https://user-images.githubusercontent.com/20812458/163763564-ebfa8ef1-43fc-46ab-8aec-9c8daf4605c4.png">


[이번 코드에서의 규칙]
- 중복 코드 제거
- 클래스 분리
- 인터페이스 분리
- 상속을 통한 확장 방법 (템플릿 메소드 패턴)
- 관심사항 분리
- 개방 폐쇄 원칙

[코드 내용]
- User와 DB의 연결 

- 중복 코드를 메소드화
```
public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
}
public void get(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
}

// 중복 코드를 메소드화
private Connection getConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
    return c;
}
```

- 추가 요구사항: N사 D사 DB가 추가
- 상속을 통한 확장 방법 (템플릿 메소드 )
```
public abstract class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        ...
    }
    public void get(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
        ...
    }
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
    private Connection getConnection() throws ClassNotFoundException, SQLException {
        // N사 DB connection 생성코드
    }
}

public class DUserDao extends UserDao {
    private Connection getConnection() throws ClassNotFoundException, SQLException {
        // D사 DB connection 생성코드
    }
}
```

- db 접속이 다시 하나일때.
- 클래스의 분리
```
public class UserDao {

    private SimpleConnectionMaker simpleConnectionMaker;
    
    public UserDao() {
        this.simpleConnectionMaker = new SimpleConnectionMaker();
    }
    
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();
        ...
    }
    
    public void get(User user) throws ClassNotFoundException, SQLException {
        Connection c = simpleConnectionMaker.makeNewConnection();
        ...
    }
    
}

public class SimpleConnectionMaker {
    public Connection makeNewConnection() ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "spring", "book");
        return c;
    }
}
```

- 추가 요구사항: N사 D사 DB가 추가
- 인터페이스 분리 
- 해당 리팩토링 과정에서 개방 폐쇄 원칙이 적용된다.(확장에는 열려있고 수정에 대해서는 닫혀있다.)
```
public interface ConnectionMaker {
    public Connection makeConnection() ClassNotFoundException, SQLException;
}

public class DConnectionMaker implements ConnectionMaker {
    ...
    private Connection makeConnection() throws ClassNotFoundException, SQLException {
        // D사 DB connection 생성코드
    }
}

public class UserDao {

    private  ConnectionMaker connectionMaker;
    
    public UserDao() {
        this.connectionMaker = new DConnectionMaker();
    }
    
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
        ...
    }
    
    public void get(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
        ...
    }
    
}
```
[출처] https://www.youtube.com/watch?v=bIeqAlmNRrA
[출처] 토비의 스프링 3.1
