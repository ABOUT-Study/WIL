# 1
## 클러스터링 vs 리플리케이션 vs 샤딩
가장 기본적인 DB 구조는 다음과 같다.

![1](https://user-images.githubusercontent.com/22884224/145668699-ec2f22fc-8773-4462-aee2-572af6a0e362.png)

하지만 위와 같은 모델은 **DB서버가 죽으면 관련된 서비스 전체가 중단된다**. 이를 해결하기 위한 방법으로, 동일한 DB서버를 2개이상 두는 **클러스터링** 이라는 방법이 있다.   

### 클러스터링
- **클러스터링은 두개 이상의 DB서버를 두기 때문에 하나의 DB서버가 죽어도 나머지 한대가 처리하면 된다. 클러스터링은 2가지 방법으로 나뉜다.**

1. **Active - Active Clustering**
    - 서버 하나가 죽어도 다른서버가 그 역할을 **바로 수행** 할 수 있다.
    - 같이 active된 상태기때문에 **CPU와 메모리 이용률을 높일 수 있다.**
    - 저장소를 하나 공유하기 때문에 **병목현상**이 일어날 수 있다.   
![2](https://user-images.githubusercontent.com/22884224/145668423-91781619-17b0-4992-b969-f3544e6afef0.png)

2. **Active - StandBy Clustering**
    - 운영하는데 Active - Active Clustering보다 **적은비용**이 든다
    - 서버가 죽으면 Stand-by가 Active로 전환되는데 시간이 들기 때문에 **그 시간동안 서비스가 중단**된다.   
![3](https://user-images.githubusercontent.com/22884224/145668424-ec97e6f1-41c0-4087-9b17-682d1aefa6fc.png)

> 위와 같은 클러스터링 2가지방법은 공통적으로 여러 DB서버들이 하나의 스토리지를 공유한다. 그렇기때문에 DB스토리지에 문제가 생기면 데이터를 복구할 수 없는 문제가 있다. 그래서 나온 개념이 **레플리케이션** 이다.

### 레플레케이션
- **DBMS시스템(DB서버+DB스토리지)을 여러개 두고 Master와 Slave로 나눠서 동일한 데이터를 처리하는 방법이다.**
- Master DB는 INSERT, UPDATE, DELETE 작업을 하고, Slave DB는 SELECT 작업을 해서 **전체 서버의 부하를 분산 시킬 수 있다**
- 하지만 데이터 자체가 엄청 많으면 Slave DB를 N대로 늘려도 원하는 데이터를 찾는데 많은 시간이 소요되는 단점은 여전히 존재한다. 이때 활용 가능한 것이 **샤딩** 이라는 방법이다.
 
![5](https://user-images.githubusercontent.com/22884224/145668426-ecb0ee40-b552-48ac-b456-46565f0192e6.png)

### 샤딩
- **샤딩은 테이블을 특정 기준으로 나눠서 저장 및 검색하는 것을 말한다. 샤딩의 핵심은 Data를 어떻게 잘 분산 시켜 저장할지, 그리고 어떻게 잘 읽을 것인지에 대한 것이다.**
- **잘 분산 시켜 저장할지에 기준이 되는것이 Shard Key**이다. Shard key를 어떻게 정의하느냐에 따라 데이터를 효율적으로 분산 시킬 수 있다.
- 여러가지 샤딩 방법이 있다.
![11](https://user-images.githubusercontent.com/22884224/145668428-548c11ea-f52e-4561-97b1-3c76e3eecca6.png)

1. **Hash Sharding**
    - Shard의 수만큼 Hash함수를 사용해서 나온 결과에 따라 DB 서버에 저장하는 방법이다.
    - 구현이 간단하는 장점이 있고, DB 서버가 추가되면 Hash함수를 수정해야하므로 확장성이 낮다.
![9](https://user-images.githubusercontent.com/22884224/145668432-e49cbc33-95cd-472a-ad19-d0de28af29cf.png)

2. **Dynamic Sharding**
    - 테이블 형식의 데이터를 바탕으로 샤드를 결정해서 저장하는 방식을 말한다.
    - 로케이터 서비스를 통해 Shard Key를 얻는다.
    - 확장에 유연하다.
    - 로케이터 서비스에 장애가 발생하면 나머지 shard 또한 문제가 발생한다.
![13](https://user-images.githubusercontent.com/22884224/145668436-c81be091-cec6-47f8-811b-a686abb14811.png)
![7](https://user-images.githubusercontent.com/22884224/145668438-7354da69-3aae-4e6a-a855-b777e559ce5e.png)

3. Entity Group, Moduler Sharding, Range Sharding 등이 있다.


[출처] https://jordy-torvalds.tistory.com/94   
[출처] https://sloth.tistory.com/34      
[출처] https://github.com/workhardslave/cs-study/blob/main/Database/NoSql%2C%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81vs%20%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%2C%20DB%EC%83%A4%EB%94%A9.md



# 2
## JWT vs 세션
- 배경 지식
    - 인증과 인가
        - 인증 :  **한마디로 로그인과 같다.** 아이디와 패스워드로 사용자임을 인증 받는것을 의미한다.
        - 인가 : 인증을 받은 사용자가 서비스 내의 **여러 기능을 사용할때 서버에 허가받는것**을 의미한다. **즉, 로그인이 유지되는 상태에서 일어나는 것**이다.
    - HTTP 프로토콜의 특징
        - Stateless : 클라이언트와 세션 정보를 서버에 저장하지 않는다. 즉, 10초전에 내가 서버에 접근했다하더라도 지금 다시 접근하면 서버가 접속한걸 모른다.
        - 그러면 서버에 요청을 할때마다 내 로그인 정보나 그밖의 데이터들을 보내야한다. 매번 무거운 작업들을 반복해야하는 단점이 있다.
        - 또한 요청할때마다 아이디, 비밀번호를 실어 보내는건 보안상 매우위험하다.
        - 그래서 나온것이 세션
 - 세션 인증 방식(= 서버에 저장)   
![123](https://user-images.githubusercontent.com/22884224/147828885-a1f6db13-bc48-4fe3-b0ef-8d6b4fd56552.png)
    1. 클라이언트가 로그인요청을하면 서버가 정보를 확인한다.
    2. 2의 과정이 성공하면 서버는 세션 저장소를 만들고 메모리나 DB에 유저 정보를 저장
    3. 서버가 클라이언트에게 유저정보에 대응하는 세션 ID를 보낸다
    4. 클라이언트의 브라우저에 세션의 ID만 쿠키에 저장한다.
    5. 이후 클라이언트는 요청마다 쿠키를 헤더에 실어 보냄
    6. 서버는 쿠키(세션 ID가 존재하는)정보로 세션 저장소를 조회해서 검증
    7. 검증이 완료되면 사용자에게 응답
- 세션의 단점
    - 세션 데이터는 서버 메모리에 저장되기때문에 **서버 확장시 모든 서버에 세션 데이터가 존재해야함.**
    - **서버자체나 세션 메모리에 장애가 일어나면 시스템에 문제가 생길 수 있음.**
    - 사용자가 **동시에 많이 접속하면 메모리가 부족**해질 수 있음.
- 토큰방식(= 클라이언트에 저장)   
![321](https://user-images.githubusercontent.com/22884224/147828798-a0abb98b-4e92-427e-9237-c8f3e1f29e77.png)
    1. 클라이언트가 로그인요청을하면 서버가 정보를 확인한다.
    2. 2의 과정이 성공하면 서버는 토큰을 생성해서 클라이언트에게 보낸다.
    3. 이후 클라이언트는 요청마다 토큰를 헤더에 실어 보냄
    4. 서버는 토큰을 서버에 저장되어있는 secret key로 풀어 검증한다.
    5. 검증이 완료되면 사용자에게 응답
    
- JWT를 만들기 위해 필요한 세가지 (Header, Payload, Signature)
    - Header ⇒ **JWT 유형(고정값)** 과 **알고리즘(SHA256, RSA)** 유형을 담고 있다.(base64로 인코딩 되어있음)
    - Payload ⇒ **클라이언트에 대한 정보**가 들어 있다. (base64로 인코딩 되어있음)
    - Signature ⇒ **Header와 Payload를 합친값을 서버의 sercret키로 해쉬해서 나온 결과 값.**
    - 로그인된 사용자가 어떤 요청을 보내면 서버가 **Header, Payload합친값을 secret key로 해싱**한다. 그리고 **그 결과값이 Signature와 맞는지 확인**한다. Signature도 일치하고 토큰의 유효기간도 지나지 않았다면 해당 요청은 인가받는다.

- JWT의 장단점
    - **이미 발급된 JWT에 대해서는 돌이킬 수 없다.** 세션/쿠키의 경우 악의적으로 활용될 경우 그냥 세션을 지워버리면 되지만, JWT의 경우 유효기간이 되기전의 토큰을 누군가 가져가면 그걸 막을 방법이 없다.
        - 보완하는 방법
            1. JWT **(Access Token)** 유효기간을 짧게 해서 누군가에게 탈취될 확률을 줄인다.
            2. 하지만 이러면 로그인을 자주 해줘야하기떄문에 이를 위해 **Refresh token**을 이용한다.
            3. Access Token이 만료될때마다 로그인 할 필요 없이 서버의 Refresh Token을 활용해서 새로운 Access Token으로 갱신한다.
        - 하지만 JWT의 단점을 완벽히 보완할 수 는 없기때문에 JWT하나만 적용하는 경우는 드물다.

[출처] https://fierycoding.tistory.com/69   
[출처] https://steadily-worked.tistory.com/468   
[출처] https://okky.kr/article/600362?note=1736719   
[출처] https://yonghyunlee.gitlab.io/node/jwt/


# 3
## RestTemplate vs WebClient

# 4

# 5

# 6

# 7

# 8

# 9

# 10

# 11

# 12
