## 전략(Strategy) 패턴

### 디자인 패턴이란

 - 기존 환경 내에서 반복적으로 일어나는 문제들을 어떻게 풀어낼 것인가에 대한 일종의 솔루션
 - 소프트웨어에서 변화는 필수적이라는 것을 인정하고 변화에 유연하게 대처하기 위한 베스트 프렉티스 모음

### 전략 패턴이란

 - 바뀌는 부분을 캡슐화해서 분리한다.
 - 그렇게 하면 나중에 바뀌는 부분에는 영향을 미치지 않은 채 바뀌는 부분만 고치거나 확장할 수 있다.

### 요구 사항

 - 오리를 정의한 Duck 슈퍼클래스가 있고, 이를 상속한 고무오리, 빨간머리 오리 등이 있다. 
 - 이와 같은 구조에서 fly() 메소드를 추가하고 싶다.

### 1. 상속을 활용하면 어떨까?

 - Duck 슈퍼 클래스에 fly() 메소드를 추가한다.
 - 그러면 Duck을 상속 받은 모든 서브클래스에서 슈퍼클래스의 fly() 메소드를 사용할 수 있게 된다.

> 문제점
> 1. 날지 못하는 고무 오리 클래스에도 fly() 메소드가 추가 된다.
> 2. 서브 클래스에서 코드가 중복된다. 고무 오리 클래스에서 fly를 날지 못하게 오버라이딩 해야하므로.
> 3. 모든 오리의 행동을 알기 어렵다.
> 4. 실행시에 특징을 바꾸기 힘들다.
> 5. 코드를 바꿨을 때 다른 오리들한테 원치 않은 영향을 끼칠 수 있다(1번의 문제점과 동일)

 - Duck의 행동이 바뀔 때마다 Duck 서브클래스에서 일일이 오버라이딩한 메소드를 수정해야하므로 상속은 옳은 방법이 아니다.

### 2. 인터페이스를 사용한다면?

 1. Duck 클래스에서 fly() 메소드와 quack() 메소드를 분리해서 flyable, Quackable 인터페이스로 만든다.
 2. 그리고 날 수 있는 Duck 서브클래스는 flyable 인터페이스를 구현하고, 꽥꽥거릴 수 있는 Duck 서브클래스는 Quackable 클래스를 구현한다.

> 문제점
> 1. 상속처럼 날 수 없는 서브클래스에 fly() 메소드가 추가되는 것을 막을 수 있지만, 코드 재사용성은 전혀 기대할 수 없게 된다.
> 2. 인터페이스의 구현체는 fly() 메소드의 바디를 직접 구현해야 하기 때문에, 모든 fly() 메소드가 같다고 한다면 모든 서브 클래스에서 fly() 메소드 구현의 중복이 일어난다.
> 3. fly 메소드 수정 시에도 모든 서브클래스의 fly 메소드를 수정해야 한다.

### 3. 전략 패턴 구현하기

 1. Duck 클래스로부터 바뀌는 부분을 분리한다. fly() 와 Quack() 이 변하는 부분이다. 모든 오리가 같은 방식으로 날거나 꽥꽥거리지 않으므로.
 2. fly() 메소드가 있는 FlyBehavior 라는 인터페이스를 만든다. 그리고 FlyWithWings, FlyNoWay 라는 클래스가 FlyBehavior를 구현한다. FlyWithWings 의 fly는 날 수 있는 동작을, FlyNoWay에서는 날 수 없는 동작을 구현한다.
 3. 이제 Duck 클래스(또는 그 서브클래스)에서 나는 행동이나 꽥꽥 소리를 내는 행동을 직접 구현하지 않고 다른 클래스(flyBehavior)에 위임한다.
 4. Duck 클래스(또는 그 서브클래스)를 생성할 때 생성자 메소드로 FlyBehavior, QuackBehavior에 행동을 결정하는 구현 클래스를 대입한다. 
 5. Duck rubberDuck = new RubberDuck() 를 했을 때 생성자에 의해 Duck 클래스의 FlyBehavior 에 FlyNoway, QuackBehavior 에 MuteQuack이 대입되었다. 이로써 참조변수 Duck으로 perfomeFly를 사용하면서 다른 동작을 할 수 있게 된다.

### 4. 결론

 1. A is B (상속) 보다 A has B (인터페이스) 가 나을 수 있다.
 2. 런타임 의존성과 컴파일 의존성의 차이를 이해하고, 결합도가 낮은 컴파일 의존성을 사용하도록 하자.
