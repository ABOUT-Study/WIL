# 1
## Jetty
- Jetty는 자바 HTTP 웹 서버이자 자바 서블릿 컨테이너다.   
웹 서버가 보통 문서를 사람들에게 제공하는 것과 관련된 반면, 제티는 대규모 소프트웨어 프레임워크에서 기계와 기계의 커뮤니테이션에 사용된다.

- 서블릿(servlet)이란 SUN 사에서 제안한 웹서비스를 위한 인터페이스로, 원칙적으로는 javax.servlet.Servlet 인터페이스의 구현체다.
일반적인 자바 독립 실행 프로그램과 달리 main 메소드가 없으며, 서블릿 컨테이너에 등록된 후 서블릿 컨테이너에 의해 생성, 호출, 소멸이 이루어진다.
즉, 클라이언트가 request를 보내면 그에 대한 결과를 다시 전송해주어야 하는데, 이러한 역할을 하는 자바 프로그램이 바로 서블릿이다.

서블릿 컨테이너(servlet container)는 이러한 서블릿을 관리하며 네트워크 통신, 서블릿의 생명주기 관리, 스레드 기반의 병렬처리를 대행한다.

![1](https://user-images.githubusercontent.com/20812458/154635676-dc3cde05-dece-43eb-bd01-e8edc90664bf.png)   

[출처] https://hochoon-dev.tistory.com/entry/Java-Jetty-%EB%9E%80

# 2
## 커스텀 어노테이션
    @Target({ElementType.METHOD}) // 1
    @Retention(RetentionPolicy.RUNTIME) // 2
    public @interface LogExclusion {

    }
@interface를 추가하여 어노테이션으로 만들어줍니다.

![2](https://user-images.githubusercontent.com/20812458/154643288-2f895004-3d36-4b85-a465-d7527ed2dd18.png)   
![3](https://user-images.githubusercontent.com/20812458/154643669-846a297b-e9b5-4bc2-92db-06e06ae944ca.png)   

    @Slf4j
    @Component
    @Aspect
    public class LogConfig {

      @Around("within(me.shinsunyoung.aop.controller..*) && !@annotation(me.shinsunyoung.aop.config.LogExclusion)")
      public Object logging(ProceedingJoinPoint pjp) throws Throwable { 

        ...
      }

     ...

    }
    
[출처] https://shinsunyoung.tistory.com/83   
[출처] https://www.inflearn.com/course/spring_revised_edition/lecture/19742?tab=curriculum&volume=0.41

# 3
## 비밀번호는 서버에 어떻게 저장할까?(= 비밀번호 암호화, 복호화)

# 4
## 3-way Handshake, 4-way Handshake

### 3-way handshake
- 3-Way Handshake는 TCP/IP프로토콜을 이용해서 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 **상대방 컴퓨터와 사전에 세션을 수립하는 과정**을 의미한다.
3번의 확인과정을 거친다고 해서 3 way handshake라고 부른다.

![4](https://user-images.githubusercontent.com/22884224/153829945-89b300e6-64a6-4e72-bf18-2e79a9978640.png)   

위의 과정을 간단히 표현하면   
1) Client → Server : 내 말 잘 들려?(SYN)   
2) Server → Client : 잘들려(ACK). 내 말은 들려?(SYN)   
3) Client → Server : 너 말도 잘 들려!(ACK)   
   
     
     
### 4-way handshake
- 3 way handshake와 반대로 연결을 해제할 떄 주고받는 확인 작업이다.

![5](https://user-images.githubusercontent.com/22884224/153830145-a72ffac9-742f-449a-a942-fb252493b003.png)   

위의 과정을 간단히 표현하면   
1) Client → Server : 나는 다 보냈어. 이제 연결 끊자(FIN)   
2) Server → Client : 알았어~ 잠시만(ACK)   
3) Server → Client : 나도 끊을게(FIN)   
4) Client → Server : 알았어(ACK)   
   
   
   
### 기억해야할것
   **TCP는 신뢰성있는 데이터 전송**을 위해 **가상 회선 연결과 해제의 과정이 필요하다**. 이때 사용하는 방법이 **3-way, 4-way handshake**이다.

# 5
## 웹 동작 방식
![1](https://user-images.githubusercontent.com/22884224/153759415-ceb3e59c-2d7c-47eb-9f40-a238ca874486.png)   
   
① ~ ② 사용자가 브라우저에 URL을 입력

③ 사용자가 입력한 URL 주소 중에서 도메인 네임 부분을 DNS 서버에서 감색함. 

④ DNS서버에서 해당 도메인 네임에 해당하는 IP주소를 찾고, URL정보에 포함시켜 전달함. 

⑤ HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함

⑥ ~ ⑦ TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨

⑨ 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함

⑩ TCP/IP 연결을 통해 요청한 컴퓨터로 전송

⑪ 도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환됨

⑫ 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨

[출처] https://velog.io/@junnoli/%EC%9B%B9%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC   
[출처] https://mangkyu.tistory.com/91?category=761303

# 6
## GraphQL이란?(gql)   

- Server API를 구성하기 페이스북에서 만들어진 쿼리 언어, REST API의 한계를 극복하고자 하는 언어.   

![캡처](https://user-images.githubusercontent.com/83939644/154802759-d4c3d96d-5c91-429b-adb9-52aac6c5329f.PNG)


※ REST API에 대한 GQL에 이점 !

endpoint가 1개 모바일 기기 사용이 증대하는 요즘 효과적인 데이터 로딩이 가능하다.

한번의 요청으로 원하는 모든 데이터를 서버로부터 요청해서 가져오기 때문에 기존에 Rest API만을 사용할때 
Overfeching 이나 Underfeching 등의 문제가 발생하지 않는다.
(Overfeching , Underfeching은 REST API의 한계라고도 할수 있다.)


기종에 상관없는 API기 때문에 특정기종을 차별하지않는 언어
```
Overfaching
 원하는 data 이상의 정보를 요청하는 것. data 전체 리소스 낭비 발생 (유저의 이름만 가져오고싶은데 API에는 유저의모든정보가 담겨있을경우)
 
UnOverfaching
원하는 data의 정보를 요청하기 위해 여러번 요청을 보내는 것. 네트워크를 통해 여러번 접근해서 리소스를 낭비 발생 (유저의 상세정보가 각각의 API에 담겨있을 경우)
```

- GraphQL 은 다음과 같은 장점을 가진다. 
1. HTTP 요청의 횟수를 줄일 수 있다.
2. GraphQL 은 원하는 정보를 하나의 Query 에 모두 담아 요청하는 것이 가능하다.
3. HTTP 응답의 Size 를 줄일 수 있다.
4. GraphQL 은 원하는 대로 정보를 요청하는 것이 가능하다.
   
- GraphQL 은 다음과 같은 단점을 가진다.   
1. File 전송 등 Text 만으로 하기 힘든 내용들을 처리하기 복잡하다.   
2. 캐싱 기능의 구현이 복잡   
3. 고정된 요청과 응답만 필요할 경우에는 Query 로 인해 요청의 크기가 RESTful API 의 경우보다 더 커진다.   

```
요청 데이터
query {
 cart {
 product_name
 price
 }
 notification {
 is_read
 }
 user(user_id: 1) {
 user_name
 user_grade
 }
}
반환 데이터
{
  "cart": [{
    "product_name": "shoes",
    "price": 12000
  }, ...],
  "notifications": [{
    is_read: true
  }],
  "user": {
    "user_name": "jim",
    "user_grade": "VVIP"
  }
}

```
