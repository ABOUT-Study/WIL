# 1
# inner join vs EXISTS


  1. inner join    
    1:n의 관계이기 때문에 결과는 n개가 출력되며 정보는 반복되어 출력됨을 알 수 있다.   
    이를 제거하려면 DISTINCT를 써서 중복 데이터를 제거할수 있다.
    
    ₩₩₩
    SELECT COUNT(DISTINCT c_name)
    FROM orders INNER JOIN customer
      ON orders.o_custkey = customer.c_custkey
    WHERE orders.o_orderDATE BETWEEN '1991-01-01'
      AND '1999-12-31';
    ₩₩₩
    
  2. EXISTS  
    EXISTS의 경우는 inner query를 만족하는 레코드를 처음 만나는 순간 EXISTS가 true이므로 inner query를 더 이상 Evaluation하지 않는다.   
    이 점이 INNER JOIN과 EXISTS의 큰 차이이며 성능의 차이를 보인다.   
    
    ₩₩₩
    SELECT COUNT(c_name)
    FROM customer WHERE EXISTS (
        SELECT 1 FROM orders 
        WHERE orders.o_custkey = customer.c_custkey
          AND orders.o_orderDATE
              BETWEEN '1991-01-01' AND '1999-12-31'
    );
    ₩₩₩
    
  3. inner join vs EXISTS   
    존재의 유무를 파악하는 쿼리를 짜야할때는 inner join 보다는 EXISTS를 사용하는게 성능에 훨씬 좋다.   
    
[출처] http://jason-heo.github.io/mysql/2014/05/30/mysql-inner-join-vs-exists.html
    
# 2
# Lombok 사용상 주의점

  1. @AllArgsConstructor, @RequiredArgsConstructor 사용금지.  
    @AllArgsConstructor, @RequiredArgsConstructor 는 매우 편리하게 생성자를 만들어주지만 개발자의 별 생각없는 꼼꼼함이 치명적 버그가 되게 만들 수 있다.   
    ```
    @AllArgsConstructor
    public static class Order {
        private long cancelPrice;
        private long orderPrice;
    }

    // 취소금액 5,000원, 주문금액 10,000원
    Order order = new Order(5000L, 10000L); 
    ```
    ```
    @AllArgsConstructor
    public static class Order {
        private long orderPrice;
        private long cancelPrice;
    }
    ```
    이 경우, IDE가 제공해주는 리팩토링은 전혀 작동하지 않고, lombok이 개발자도 인식하지 못하는 사이에 생성자의 파라미터 순서를 필드 선언 순서에 맞춰 orderPrice,cancelPrice로 바꿔버린다.   
    게다가 이 두 필드는 동일한 Type 이라서 기존 생성자호출 코드에서는 인자 순서를 변경하지 않았음에도 어떠한 오류도 발생하지 않는다.   
   
    이에 의해, 위의 생성자를 호출하는 코드는 아무런 에러없이 잘 작동하는 듯 보이지만 실제로 입력된 값은 바뀌어 들어가게 된다.

   2. @Data 사용금지   
    @Data는 파라미터 없는 @EqualsAndHashCode와 @RequiredArgsConstructor 등을 포함하는 Mutable한 데이터 클래스를 만들어주는 조합형 애노테이션이다.   
    바로 @EqualsAndHashCode와 @RequiredArgsConstructor를 포함하기 때문에 사용을 아예 금지하고, 차라리 다음과 같이 명시하는 것이 좋다.
    
    ₩₩₩
    @Getter
    @Setter
    @ToString
    public class Order {
    ...
        // 생성자와 필요한 경우에만 equals, hashCode 직접 작성
    }
    ₩₩₩
    
   3. @Builder 를 생성자나 static 객체 생성 메소드에   
    @Builder 를 사용하면 객체 생성이 좀 더 명확하고 쉬워지는데, 이는 기본적으로 @AllArgsConstructor를 내포하고 있다.   
    이 자체는 평상시에는 큰 문제가 안된다. 생성자를 package private으로 만들기 때문에 외부에서 생성자를 호출하는 일은 쉽게 안생긴다.   
    하지만 그래도 해당 클래스의 다른 메소드에서 이렇게 자동으로 생성된 생성자를 사용하거나 할 때 문제 소지가 있다.   
    따라서 @Builder 애노테이션은 가급적 클래스 보다는 직접 만든 생성자 혹은 static 객체 생성 메소드에 붙이는 것을 권장한다. (생성자 부분에 예시 나옴)   
    
    
  [출처] https://kwonnam.pe.kr/wiki/java/lombok/pitfall

