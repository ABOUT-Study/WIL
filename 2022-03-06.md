# 1 @Transactional 어노테이션
## 트랜잭션 격리 수준
  데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질 네가지가 존재합니다. (ACID)
  - 원자성(Atomicity): 모든 작업이 반영되거나 모두 롤백되는 특성입니다
  - 일관성(Consistency): 데이터는 미리 정의된 규칙에서만 수정이 가능한 특성을 의미합니다. 숫자컬럼에 문자열값을 저장이 안되도록 보장해줍니다.
  - 격리성(Isolation): A와 B 두개의 트랜젝션이 실행되고 있을 때, A의 작업들이 B에게 보여지는 정도를 의미합니다.
  - 지속성(Durability): 한번 반영(커밋)된 트랜젝션의 내용은 영원히 적용되는 특성을 의미합니다.
## 옵션 
  - isolation -> 일관성 (Consistency) 는 비례
    - DEFAULT: 사용하는 DB 의 기본 격리 수준을 따름
    - READ_UNCOMMITTED: 커밋되지 않은 데이터를 다른 트랜잭션에서 접근 가능합니다.
    - - REPEATABLE_READ: 트랜잭션은 커밋한 데이터만 읽을 수 있습니다.
    - READ_COMMITTED: 간단히 말하면 하나의 트랜잭션은 하나의 스냅샷만 사용하는 겁니다.   
                      A 트랜잭션이 시작하고 처음 조회한 데이터의 스냅샷을 저장하고 이후에 동일한 쿼리를 호출하면 스냅샷에서 데이터를 가져옵니다.   
                      따라서 중간에 B 트랜잭션이 새로 커밋해도 A 트랜잭션이 조회하는 데이터는 변하지 않습니다.
    - SERIALIZABLE: 순차적으로 트랜잭션을 진행시키며 읽기 작업에도 잠금을 걸어 여러 트랜잭션이 동시에 같은 데이터에 접근하지 못합니다.
  - propagation -> 현재 진행중인 트랜잭션 (부모 트랜잭션) 이 존재할 때 새로운 트랜잭션 메소드를 호출하는 경우 어떤 정책을 사용할 지에 대한 정의입니다.
    - REQUIRED: 기본값이며 부모 트랜잭션이 존재할 경우 참여하고 없는 경우 새 트랜잭션을 시작
    - SUPPORTS: 부모 트랜잭션이 존재할 경우 참여하고 없는 경우 non-transactional 상태로 실행
    - MANDATORY: 부모 트랜잭션이 있으면 참여하고 없으면 예외 발생
    - REQUIRES_NEW: 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션이 생성 (새로운 트랜잭션에서 에러 발생해도 부모트랜잭션은 롤백을 하지 않음)
    - NOT_SUPPORTED: non-transactional 상태로 실행하며 부모 트랜잭션이 존재하는 경우 일시 정지시킴
    - NEVER: non-transactional 상태로 실행하며 부모 트랜잭션이 존재하는 경우 예외 발생
    - NESTED:
      - 부모 트랜잭션과는 별개의 중첩된 트랜잭션을 만듬
      - 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않음
      - 부모 트랜잭션이 없는 경우 새로운 트랜잭션을 만듬 (REQUIRED 와 동일)
      - DB 가 SAVEPOINT 를 지원해야 사용 가능 (Oracle)
      - JpaTransactionManager 에서는 지원하지 않음
  - readOnly -> 기본값은 false 이며 true 로 세팅하는 경우 트랜잭션을 읽기 전용으로 변경합니다. (성능에 영향을 줌)
  - rollbackFor -> 기본값 @Transactional(rollbackFor = {RuntimeException.class, Error.class}) 해당 에러일 경우 롤백
  - timeout -> 기본값 @Transactional(timeout = -1) 지정한 시간 내에 해당 메소드 수행이 완료되이 않은 경우 JpaSystemException 을 발생시킵니다. -1은 타임아웃 시간이 무한이다.
  
  [출처] https://bcp0109.tistory.com/322   
  [출처] https://chrisjune-13837.medium.com/db-transaction-%EA%B3%BC-acid%EB%9E%80-45a785403f9e   
  [출처] https://jsonobject.tistory.com/467   
  [출처] https://pjh3749.tistory.com/269
  
# 2 UnaryOperator, default 메서드
## UnaryOperator 
  - UnaryOperator는 Type T의 인자 하나를 받고, 동일한 Type T 객체를 리턴하는 함수형 인터페이스입니다.
  ```
  public interface UnaryOperator<T> extends Function<T, T> {

  }
  ```
  
  UnaryOperator는 Function을 상속하며, apply()를 호출하여 어떤 작업을 수행할 수 있습니다.
  
  ```
  import java.util.function.UnaryOperator;

  public class UnaryOperatorExample1 {
      public static void main(String[] args) {

          UnaryOperator<Integer> unaryOperator1 = n -> n * n;
          Integer result = unaryOperator1.apply(10);
          System.out.println(result);

          UnaryOperator<Boolean> unaryOperator2 = b -> !b;
          Boolean result2 = unaryOperator2.apply(true);
          System.out.println(result2);
      }
  }
  ```
  밑에와 같이 메소드에서 UnaryOperator로 파라미터를 받으면 람다 표현식으로 펴현이 가능합니다.
  
  ![image](https://user-images.githubusercontent.com/20812458/156513464-552b24e7-c9ac-47da-8779-479fc44a4cf9.png)
  
  밑에와 같이 사용할수 있습니다.
  (예제 요구사항 "날짜를 하루씩 다음날로 바꾸는데 이떄 토요일과 일요일은 건너뛴다")
  

  ```
  TemporalAdjuster nextWorkingDay = TemporalAdjusters.ofDateAdjuster(
    temporal -> {
      DayOfWeek dow =
              DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));
      int dayToAdd = 1;
      if (dow == DayOfWeek.FRIDAY) dayToAdd = 3;
      else if (dow == DayOfWeek.SATURDAY) dayToAdd = 2;
      return temporal.plus(dayToAdd, ChronoField.DAYS);
  });
  LocalDate date = LocalDate.now();
  date = date.with(nextWorkingDay);
  ```
  
## default 메서드
  - 정의
    - 인터페이스는 자신을 구현하는 클래스에서 메서드를 구현하지 않을 수 있는 새로운 메서드 시그니처를 제공하는데 그것이 default 메서드입니다.

  - 대상
    - API는 새로운 메서드를 추가하면 기존 구현에 문제가 생길수 있습니다.
      List 인터페이스에 새로운 메서드가 추가하면 List를 가져다 사용한 모든 사용자는 컴피알 에러가 생깁니다. 그러한 문제를 방지하기 위해 사용합니다.

  - 추상 클래스와 자바 8의 인터페이스

    [공통점]
    - 둘 다 추상 메서드와 바디를 포함하는 메서드를 정의 할 수 있습니다.
    
    [차이점]
    - 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스는 여러 개 구현할 수 있습니다.
    - 추상 클래스는 인스턴스 변수(필드)로 공통 상태를 가질 수 있습니다. 하지만 인터페이스는 인스턴스 변수를 가질 수 없습니다.
    
    
  List 인터페이스의 한 부분을 가져왔습니다.
  
  ```
  public interface List<E> extends Collection<E> {
    ...
    
    @SuppressWarnings({"unchecked", "rawtypes"})
    default void sort(Comparator<? super E> c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator<E> i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
    
    ...
  }
  
  public class Number {
    public void test() {
      List<Integer> numbers = Arrays.asList(3, 5, 1, 2, 6);
      numbers.sort(Comparator.naturalOrder()); // sort는 List 인터페이스의 디폴트 메서드입니다.
    }
  }
  
  ```
  
  [출처] https://codechacha.com/ko/java8-unaryoperator-example/   
  [출처] 모던 자바 인 액션

# 3 hikariCP

  - 정의
    - SpringBoot2.0부터 default JDBC connection pool로 지정된 DBCP(Database Connection Pool)입니다.

  - DBCP(DataBase Connection Pool)란 
    - DB Connection 객체를 미리 만들어 Connection Pool에 보관하고 필요할 때마다 DB에 연결된 Connection을 꺼내 사용하는 것을 의미합니다.
    - Connection Pool을 사용하는 이유는 Connection 객체를 만드는 것이 큰 비용을 소모하는 작업이기 때문입니다. 
      미리 만들어진 Connection을 재사용하여 CPU의 부담과 Connection을 생성하는데 필요한 시간을 줄일 수 있습니다. 
      
  - 사용법
    - 디펜던시 등록
    - application.yml에 옵션 등록

  ```
   /* application.yml */ 

  spring:
      datasource:
          hikari:
              connectionTimeout : 30000
              maximumPoolSize : 10
              maxLifetime : 1800000
              poolName : HikariCP
              readOnly : false
              connectionTestQuery : SELECT 1
  ```
  
  - 옵션
    1) connectionTimeout (default : 30000 (30 seconds))
      > 클라이언트가 pool에 connection을 요청하는데 기다리는 최대시간을 설정합니다. 설정한 시간을 초과하면 SQLException이 발생합니다. (허용 가능한 최소 연결 시간은 250ms )
    2) maximunPoolSize (default : 10) 
      > 유휴 및 사용중인 connection을 포함하여 풀에 보관가능한 최대 커넥션 개수를 설정합니다. 사용할 수 있는 커넥션이 없다면 connectionTimeout 시간 만큼 대기하고 시간을 초과하면 SQLException이 발생합니다. 
    3) minimumIdle (default : maximumPoolSize와 동일) 
      > connection pool에서 유지가능한 최소 커넥션 개수를 설정합니다. 최적의 성능과 응답성을 원하면 이 값을 설정하지 않는게 좋다고 합니다.
    4) idleTimeout (default : 600000 (10분))
      > connection pool에서 유휴 상태로 유지시킬 최대 시간을 설정합니다. 이 설정은 minimumIdle이 maximumPoolSize보다 작은 경우에만 사용할 수 있습니다. 
        pool에 있는 connection이 minimumIdle에 도달할 경우 이후에 반환되는 connection에 대해서 바로 반환하지 않고 idleTimeout 만큼 유휴 상태로 있다가 폐기됩니다.
    5) maxLifeTime (default : 1800000 (30분))
      > connection의 최대 유지 시간을 설정합니다. connection의 maxLifeTime 지났을 때, 사용중인 connection은 바로 폐기되지않고 작업이 완료되면 폐기됩니다. 하지만 유휴 커넥션은 바로 폐기됩니다.
    6) readOnly (default : false)
      > pool에서 얻은 connection이 기본적으로 readOnly인지 지정하는 설정입니다. 데이터베이스가 readOnly 속성을 지원할 경우에만 사용할 수 있습니다.
    7) connectionTestQuery (default : none)
      > 데이터베이스 연결이 여전히 활성화되어있는지 확인하기 위해 pool에서 connection을 제공하기 전에 실행되는 쿼리입니다. 드라이버가 JDBC4를 지원하는 경우 이 속성을 사용하지 않는 것이 좋다고합니다.
   
  [출처] https://bamdule.tistory.com/166   
  [출처] https://bamdule.tistory.com/167   
  
# 4

# 5
