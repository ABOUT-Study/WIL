# 1
# reactive streams 란?
  논블로킹(Non-blocking) 백프레셔(back pressure)를 이용한 비동기 데이터 처리의 표준이다
  
  백프레셔(back pressure) : Publisher 에서 발행하고, Subscriber에서 구독할 때  
  , Publisher 에서 데이터를 Subscriber 로 Push 하는 방식이 아니라   
  , Pull 방식으로 Subscriber 가 Publisher 로 처리할 수 있는 양의 크기만큼 데이터를 요청 함으로써 Subscriber의 장애를 방지하기 위함이다.   
  즉, 다이나믹 풀 방식의 데이터 요청을 통해서 구독자가 수용할 수 있는 만큼 데이터를 요청하는 방식이다.   

# 2
# Webflux 란?
  스프링5는 Spring Boot 2 부터 도입이 되었으니, Spring Boot 2 의 stack 는 아래와 같다.   
  개발자는 Reactive Stack 를 사용할지, Servlet Stack 를 사용할지 선택을 해야 한다. 두개의 stack 을 동시에 사용할 수 없다.
  
  ![1](https://user-images.githubusercontent.com/20812458/144557919-9cd4f741-ed00-486e-8e00-aa9e9ffb37ab.png)
  
  * 스프링 웹플럭스는 왜 탄생했는가?
    이 물음에 대한 답 일부는, 논 블로킹 웹 스택이 적은 수의 쓰레드와 보다 적은 하드웨어 자원으로 동시성을 처리하기 위함이다.   
    서블릿 3.1 에서도 이미 논 블로킹 I/O를 다루기 위한 API를 제공하지만, 이 API를 사용하면 다른 나머지 서블릿 API와는 멀어지게 된다   
    (필터, 서블릿과 같은 동기 방식 처리나 getParameter, getPart 등 블로킹 API).   
    이런 점이 어떠한 논 블로킹 런타임에서든 기반 역할로 지원하는 새로운 공통 API의 탄생  동기가 되었다.   
    네티와 같이 비동기, 논 블로킹 영역이 잘 구현된 서버로 인해 이 점은 중요하다.   
    
    스프링 웹플럭스의 또다른 탄생 배경은 함수형 프로그래밍이다.   
    자바 8 에서 추가된, 함수형 API를 위한 람다 표현식은 자바 5 의 어노테이션(어노테이티드 REST 컨트롤러, 단위 테스트)만큼이나 자바 세계에 새로운 기회를 제공한다.   
    
    ![2](https://user-images.githubusercontent.com/20812458/144559369-a615efb2-f38d-4dc9-9dfd-d9c1ab8c3a6d.png)
  
# 3
# Flux 와 Mono

  "Reactive Streams" 인터페이스 중에서 Publisher 를 구현을 해 놓은 발행자이다.
  Flux 와 Mono 의 차이점은 발행하는 데이터 갯수이다.
    - Flux : 0 ~ N 개의 데이터 전달
    - Mono : 0 ~ 1 개의 데이터 전달
    
   둘다 스트림 형식의 계산을 가능하게한다.
   

[출처] https://parkcheolu.tistory.com/134   
[출처] https://hyunsoori.tistory.com/3   
[출처] https://www.youtube.com/watch?v=4x1QRyMIjGU

# 4


# 5


# 6
