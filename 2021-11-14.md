# 1
# inner join vs EXISTS


  1. inner join    
    1:n의 관계이기 때문에 결과는 n개가 출력되며 정보는 반복되어 출력됨을 알 수 있다.   
    이를 제거하려면 DISTINCT를 써서 중복 데이터를 제거할수 있다.
    
    ₩₩₩
    SELECT COUNT(DISTINCT c_name)
    FROM orders INNER JOIN customer
      ON orders.o_custkey = customer.c_custkey
    WHERE orders.o_orderDATE BETWEEN '1991-01-01'
      AND '1999-12-31';
    ₩₩₩
    
  2. EXISTS  
    EXISTS의 경우는 inner query를 만족하는 레코드를 처음 만나는 순간 EXISTS가 true이므로 inner query를 더 이상 Evaluation하지 않는다.   
    이 점이 INNER JOIN과 EXISTS의 큰 차이이며 성능의 차이를 보인다.   
    
    ₩₩₩
    SELECT COUNT(c_name)
    FROM customer WHERE EXISTS (
        SELECT 1 FROM orders 
        WHERE orders.o_custkey = customer.c_custkey
          AND orders.o_orderDATE
              BETWEEN '1991-01-01' AND '1999-12-31'
    );
    ₩₩₩
    
  3. inner join vs EXISTS   
    존재의 유무를 파악하는 쿼리를 짜야할때는 inner join 보다는 EXISTS를 사용하는게 성능에 훨씬 좋다.   
    
[출처] http://jason-heo.github.io/mysql/2014/05/30/mysql-inner-join-vs-exists.html
    
# 2
# Lombok 사용상 주의점

  1. @AllArgsConstructor, @RequiredArgsConstructor 사용금지.  
    @AllArgsConstructor, @RequiredArgsConstructor 는 매우 편리하게 생성자를 만들어주지만 개발자의 별 생각없는 꼼꼼함이 치명적 버그가 되게 만들 수 있다.   
    ```
    @AllArgsConstructor
    public static class Order {
        private long cancelPrice;
        private long orderPrice;
    }

    // 취소금액 5,000원, 주문금액 10,000원
    Order order = new Order(5000L, 10000L); 
    ```
    ```
    @AllArgsConstructor
    public static class Order {
        private long orderPrice;
        private long cancelPrice;
    }
    ```
    이 경우, IDE가 제공해주는 리팩토링은 전혀 작동하지 않고, lombok이 개발자도 인식하지 못하는 사이에 생성자의 파라미터 순서를 필드 선언 순서에 맞춰 orderPrice,cancelPrice로 바꿔버린다.   
    게다가 이 두 필드는 동일한 Type 이라서 기존 생성자호출 코드에서는 인자 순서를 변경하지 않았음에도 어떠한 오류도 발생하지 않는다.   
   
    이에 의해, 위의 생성자를 호출하는 코드는 아무런 에러없이 잘 작동하는 듯 보이지만 실제로 입력된 값은 바뀌어 들어가게 된다.

   2. @Data 사용금지   
    @Data는 파라미터 없는 @EqualsAndHashCode와 @RequiredArgsConstructor 등을 포함하는 Mutable한 데이터 클래스를 만들어주는 조합형 애노테이션이다.   
    바로 @EqualsAndHashCode와 @RequiredArgsConstructor를 포함하기 때문에 사용을 아예 금지하고, 차라리 다음과 같이 명시하는 것이 좋다.
    
    ₩₩₩
    @Getter
    @Setter
    @ToString
    public class Order {
    ...
        // 생성자와 필요한 경우에만 equals, hashCode 직접 작성
    }
    ₩₩₩
    
   3. @Builder 를 생성자나 static 객체 생성 메소드에   
    @Builder 를 사용하면 객체 생성이 좀 더 명확하고 쉬워지는데, 이는 기본적으로 @AllArgsConstructor를 내포하고 있다.   
    이 자체는 평상시에는 큰 문제가 안된다. 생성자를 package private으로 만들기 때문에 외부에서 생성자를 호출하는 일은 쉽게 안생긴다.   
    하지만 그래도 해당 클래스의 다른 메소드에서 이렇게 자동으로 생성된 생성자를 사용하거나 할 때 문제 소지가 있다.   
    따라서 @Builder 애노테이션은 가급적 클래스 보다는 직접 만든 생성자 혹은 static 객체 생성 메소드에 붙이는 것을 권장한다. (생성자 부분에 예시 나옴)   
    
    
  [출처] https://kwonnam.pe.kr/wiki/java/lombok/pitfall

# 4 
### Garbage Collection(= GC)

- GC가 뭐야?
    - JVM의 Heap 영역에서 사용되지 않는 객체를 삭제하는 프로세스이자 메모리 관리 기법이다. (Heap 영역에는 Object타입의 데이터들이 할당된다. String, List, 커스텀 클래스 등)
- GC는 어떻게 해서 삭제해야할 객체를 판별할수 있을까?
    
    ![1.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/348133e2-77d4-4341-813c-73baa0961640/1.png)
    
    - **GCRoot(=Stack)** 부터 하나씩 탐색해나가면서 참조되고 있는 객체들을 판별한다. 참조되고 있는 객체는 **Reachable Object**, 참조되고 있지 않은 객체들은 **Unreachable Object**라 한다.  (GCRoot는 stack 영역의 데이터, method 영역의 static 데이터 등등이 될 수 있다)
- GC 동작 과정
    - **Mark and Sweep**
        - Mark : GCRoot로부터 모든 변수를 스캔하면서 **Reachable Object** 와 **Unreachable Objec**t를 마킹하는 과정
            
            ![2.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e6c46af-a1c0-48bf-8f65-1ad9f25ec940/2.png)
            
        
        - Sweep : **Unreachable Objec**t를 Heap에서 삭제하는 과정
            
            ![3.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b9f67a0b-3124-4804-af23-0aa2db4d44a9/3.png)
            
        
        - Compact : 매번 이루어지는 과정은 아니지만 Sweep후에 분산된 메모리를 정리해서 메모리 단편화를 막아주는 과정
            
            ![4.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8732d37d-63ab-474e-9a9b-000456bb6c8c/4.png)
            
- GC는 언제 일어날까? ( Heap의 구조 )
    
    ![5.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d82a48b8-4de2-4548-aa6f-c42e6ce1f1db/5.png)
    
    - Eden : 새로운 객체들이 생성되는 영역
    - Survival 0, Survival1 : Eden에서 minor GC로 부터 살아남은 객체들이 존재하는 영역
    - Survival0, Survival1 중에 하나의 영역은 비워져 있어야한다.
    
    1. Eden 영역에 객체들이 꽉차서 minor GC가 동작
        
        ![6.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6211d851-e5b3-4783-91db-80713b24f5ea/6.png)
        
    2. 살아남은 객체들은 Survival0으로 이동한다. 이때  age-bit라는 숫자가 하나 증가한다.
        
        ![8.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c0959e82-b064-4876-b553-bf1dac930f2e/8.png)
        
    3. Eden 영역에 새로운 객체들이 들어오고 꽉차서 다시 minor GC가 동작. 
        
        ![22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/82c98ac5-c925-4071-a8ac-cdaba087bcc7/22.png)
        
    4. 살아남은 객체 + Survival0의 객체들이 age-bit가 하나씩 증가해서 Survival1로 이동.
        
        ![33.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fe818e89-980c-48b1-8660-49a5f5ca6d66/33.png)
        
        ![44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/58b29171-ad47-4110-99cf-50804782791c/44.png)
        
    5. 이 과정을 반복하다가 어떤 객체의 age-bit가 일정 값을 넘으면 GC가 해당 객체는 오래된 객체라 판단해서 Old generation으로 이동시킴, 이를 Promotion 이라한다.
        
        ![55.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f8ab89c0-7b3c-4626-a18a-60426e9fc5f1/55.png)
        
    6. 나중에는 Old generation에도 객체들이 가득차면 major GC가 이루어진다.  
        
        ![66.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7474e9ef-f08a-448c-afcd-b3f5fb284fc5/66.png)
        

- Young generation과 Old generation을 나눈 이유는 대부분의 객체들이 금방 소멸되는데, 전체영역을 처리하는것보다 사이즈가 작은 Young Generation에서 처리하는것이 성능상 더 좋기 때문이다.

[출처] https://www.youtube.com/watch?v=Fe3TVCEJhzo   
[출처] https://www.youtube.com/watch?v=FMUpVA0Vvjw&t=358s
