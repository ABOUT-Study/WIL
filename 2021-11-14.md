# 1
# inner join vs EXISTS


  1. inner join    
    1:n의 관계이기 때문에 결과는 n개가 출력되며 정보는 반복되어 출력됨을 알 수 있다.   
    이를 제거하려면 DISTINCT를 써서 중복 데이터를 제거할수 있다.
    
    ₩₩₩
    SELECT COUNT(DISTINCT c_name)
    FROM orders INNER JOIN customer
      ON orders.o_custkey = customer.c_custkey
    WHERE orders.o_orderDATE BETWEEN '1991-01-01'
      AND '1999-12-31';
    ₩₩₩
    
  2. EXISTS  
    EXISTS의 경우는 inner query를 만족하는 레코드를 처음 만나는 순간 EXISTS가 true이므로 inner query를 더 이상 Evaluation하지 않는다.   
    이 점이 INNER JOIN과 EXISTS의 큰 차이이며 성능의 차이를 보인다.   
    
    ₩₩₩
    SELECT COUNT(c_name)
    FROM customer WHERE EXISTS (
        SELECT 1 FROM orders 
        WHERE orders.o_custkey = customer.c_custkey
          AND orders.o_orderDATE
              BETWEEN '1991-01-01' AND '1999-12-31'
    );
    ₩₩₩
    
  3. inner join vs EXISTS   
    존재의 유무를 파악하는 쿼리를 짜야할때는 inner join 보다는 EXISTS를 사용하는게 성능에 훨씬 좋다.   
    
[출처] http://jason-heo.github.io/mysql/2014/05/30/mysql-inner-join-vs-exists.html
    
# 2
# Lombok 사용상 주의점

  1. @AllArgsConstructor, @RequiredArgsConstructor 사용금지.  
    @AllArgsConstructor, @RequiredArgsConstructor 는 매우 편리하게 생성자를 만들어주지만 개발자의 별 생각없는 꼼꼼함이 치명적 버그가 되게 만들 수 있다.   
    ```
    @AllArgsConstructor
    public static class Order {
        private long cancelPrice;
        private long orderPrice;
    }

    // 취소금액 5,000원, 주문금액 10,000원
    Order order = new Order(5000L, 10000L); 
    ```
    ```
    @AllArgsConstructor
    public static class Order {
        private long orderPrice;
        private long cancelPrice;
    }
    ```
    이 경우, IDE가 제공해주는 리팩토링은 전혀 작동하지 않고, lombok이 개발자도 인식하지 못하는 사이에 생성자의 파라미터 순서를 필드 선언 순서에 맞춰 orderPrice,cancelPrice로 바꿔버린다.   
    게다가 이 두 필드는 동일한 Type 이라서 기존 생성자호출 코드에서는 인자 순서를 변경하지 않았음에도 어떠한 오류도 발생하지 않는다.   
   
    이에 의해, 위의 생성자를 호출하는 코드는 아무런 에러없이 잘 작동하는 듯 보이지만 실제로 입력된 값은 바뀌어 들어가게 된다.

   2. @Data 사용금지   
    @Data는 파라미터 없는 @EqualsAndHashCode와 @RequiredArgsConstructor 등을 포함하는 Mutable한 데이터 클래스를 만들어주는 조합형 애노테이션이다.   
    바로 @EqualsAndHashCode와 @RequiredArgsConstructor를 포함하기 때문에 사용을 아예 금지하고, 차라리 다음과 같이 명시하는 것이 좋다.
    
    ₩₩₩
    @Getter
    @Setter
    @ToString
    public class Order {
    ...
        // 생성자와 필요한 경우에만 equals, hashCode 직접 작성
    }
    ₩₩₩
    
   3. @Builder 를 생성자나 static 객체 생성 메소드에   
    @Builder 를 사용하면 객체 생성이 좀 더 명확하고 쉬워지는데, 이는 기본적으로 @AllArgsConstructor를 내포하고 있다.   
    이 자체는 평상시에는 큰 문제가 안된다. 생성자를 package private으로 만들기 때문에 외부에서 생성자를 호출하는 일은 쉽게 안생긴다.   
    하지만 그래도 해당 클래스의 다른 메소드에서 이렇게 자동으로 생성된 생성자를 사용하거나 할 때 문제 소지가 있다.   
    따라서 @Builder 애노테이션은 가급적 클래스 보다는 직접 만든 생성자 혹은 static 객체 생성 메소드에 붙이는 것을 권장한다. (생성자 부분에 예시 나옴)   
    
    
  [출처] https://kwonnam.pe.kr/wiki/java/lombok/pitfall

# 4 
### Garbage Collection(= GC)

- GC가 뭐야?
    - JVM의 Heap 영역에서 사용되지 않는 객체를 삭제하는 프로세스이자 메모리 관리 기법이다. (Heap 영역에는 Object타입의 데이터들이 할당된다. String, List, 커스텀 클래스 등)
- GC는 어떻게 해서 삭제해야할 객체를 판별할수 있을까?
    
    ![1](https://user-images.githubusercontent.com/22884224/140840691-d176a0af-b70d-433a-9a89-0187c0f5be33.png)
    
    - **GCRoot(=Stack)** 부터 하나씩 탐색해나가면서 참조되고 있는 객체들을 판별한다. 참조되고 있는 객체는 **Reachable Object**, 참조되고 있지 않은 객체들은 **Unreachable Object**라 한다.  (GCRoot는 stack 영역의 데이터, method 영역의 static 데이터 등등이 될 수 있다)
- GC 동작 과정
    - **Mark and Sweep**
        - Mark : GCRoot로부터 모든 변수를 스캔하면서 **Reachable Object** 와 **Unreachable Objec**t를 마킹하는 과정
            
            ![2](https://user-images.githubusercontent.com/22884224/140841591-6c814830-35bf-4c55-b4a9-e50e2ae77a3a.png)
            
        
        - Sweep : **Unreachable Objec**t를 Heap에서 삭제하는 과정
            
            ![3](https://user-images.githubusercontent.com/22884224/140841620-d577243f-bf8a-40cc-bcf9-64fa7bdb0577.png)
            
        
        - Compact : 매번 이루어지는 과정은 아니지만 Sweep후에 분산된 메모리를 정리해서 메모리 단편화를 막아주는 과정
            
            ![4](https://user-images.githubusercontent.com/22884224/140841636-64c7fc2c-ea20-436a-acce-ee9d7e703efb.png)
            
- GC는 언제 일어날까? ( Heap의 구조 )
    
    ![5](https://user-images.githubusercontent.com/22884224/140841647-50536ca9-2ec4-474e-aed4-8d69c6715618.png)
    
    - Eden : 새로운 객체들이 생성되는 영역
    - Survival 0, Survival1 : Eden에서 minor GC로 부터 살아남은 객체들이 존재하는 영역
    - Survival0, Survival1 중에 하나의 영역은 비워져 있어야한다.
    
    1. Eden 영역에 객체들이 꽉차서 minor GC가 동작
        
        ![6](https://user-images.githubusercontent.com/22884224/140841657-23546789-e62a-4520-b6fb-7de1b3661e35.png)

        
    2. 살아남은 객체들은 Survival0으로 이동한다. 이때  age-bit라는 숫자가 하나 증가한다.
        
        ![7](https://user-images.githubusercontent.com/22884224/140841679-4e064496-2052-4f6b-af99-9b51e3605d46.png)
        
    3. Eden 영역에 새로운 객체들이 들어오고 꽉차서 다시 minor GC가 동작. 
        
        ![8](https://user-images.githubusercontent.com/22884224/140841691-463bbce0-c351-4dbf-a96d-a9673dbf35c9.png)
        
    4. 살아남은 객체 + Survival0의 객체들이 age-bit가 하나씩 증가해서 Survival1로 이동.
        
        ![9](https://user-images.githubusercontent.com/22884224/140841700-a3a44995-7933-46a7-9b86-97e30c20ffcf.png)
        
        ![10](https://user-images.githubusercontent.com/22884224/140841712-a6c6333a-7a2a-44a2-a478-42b1fad979c8.png)
        
    5. 이 과정을 반복하다가 어떤 객체의 age-bit가 일정 값을 넘으면 GC가 해당 객체는 오래된 객체라 판단해서 Old generation으로 이동시킴, 이를 Promotion 이라한다.
        
        ![11](https://user-images.githubusercontent.com/22884224/140841729-5f765bb7-1444-4ddd-a1f4-25d48ed82712.png)
        
    6. 나중에는 Old generation에도 객체들이 가득차면 major GC가 이루어진다.  
        
        ![12](https://user-images.githubusercontent.com/22884224/140841741-e0d06d3f-1bf7-4dde-bf3b-8450e828d638.png)
        

- Young generation과 Old generation을 나눈 이유는 대부분의 객체들이 금방 소멸되는데, 전체영역을 처리하는것보다 사이즈가 작은 Young Generation에서 처리하는것이 성능상 더 좋기 때문이다.

[출처] https://www.youtube.com/watch?v=Fe3TVCEJhzo   
[출처] https://www.youtube.com/watch?v=FMUpVA0Vvjw&t=358s

# 5
## JPA의 성능 최적화 방법 (=영속성 컨텍스트 특징)

1. 1차 캐시
    - 영속성 컨텍스트 내부에는 **1차 캐시라는 공간**이 존재한다. 영속상태의 엔티티는 모두 1차 캐시에 저장된다. 엔티티를 조회할때 DB에 접근하는 것이 아니고, 1차 캐시에 먼저 접근해서 조회한다.
    ![111](https://user-images.githubusercontent.com/22884224/141466882-05ebc2f9-dc3e-4fac-934a-39eba487f5a5.png)
    - 1차 캐시에 없을 경우에만 DB에 접근해서 조회한 후 1차 캐시에 다시 저장한다.
    ![222](https://user-images.githubusercontent.com/22884224/141466902-fe6ff43d-1074-479e-8999-f3bfdfa99ff8.png)
    
2. 동일성 보장
    - 모든 엔티티들은 1차 캐시에 저장되기때문에, 식별자가 동일한 엔티티는 같은 객체임을 보장한다.
    ![333](https://user-images.githubusercontent.com/22884224/141466958-b1d6c9f9-3bc8-41f2-898b-fa7d2b43b410.png)
    
3. 쓰기 지연 ⇒ INSERT 쿼리를 실행하면 DB에 바로 보내지는 것이 아니라 **쓰기지연SQL저장소**에 모아둔다. 그리고 코드에서 commit을 실행하게 되면 flush를 통해 쿼리들이 **한번에 DB에 보내지고** commit을 통해 DB에 쿼리가 반영된다.
    ![444](https://user-images.githubusercontent.com/22884224/141466986-11c2a614-1391-4b4d-a4f4-2dc618f1691d.png)
    ![555](https://user-images.githubusercontent.com/22884224/141467014-ff03645b-614b-4995-92f3-5291b4b20ca8.png)

4. 변경 감지(Dirty Checking)
    - 스냅샷 : 영속성컨텍스트 1차캐시에는 **스냅샷**이라는 것이 존재한다. 스냅샷은 1차 캐시에 데이터가 저장될때 생겨난다.
    - 코드에서 커밋을 호출하게 되면, **현재 엔티티와 스냅샷을 비교**해서 현재 엔티티가 변경됐는지 체크한다. 변경됐다면 UPDATE 쿼리를 생성해서 쓰기지연 SQL저장소에 저장한다.  그리고 flush를 통해 쿼리들이 한번에 DB에 보내지고 commit을 통해 DB에 쿼리가 반영된다.
    ![666](https://user-images.githubusercontent.com/22884224/141467029-9fae7653-abc2-465b-b282-00e01cd96719.png)

5. 지연로딩과 즉시 로딩
    - 지연로딩 : 객체가 실제 사용될때 로딩
    - 즉시로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회

[출처] [https://junjangsee.github.io/2019/05/15/interview/interview/](https://junjangsee.github.io/2019/05/15/interview/interview/)


# 6
## 가상 메모리란?
   메모리 관리 기법 중 하나로 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능** 하도록 하는 기
1. 사용자 프로그램이 물리 메모리의 제약에서 벗어남
2. 각 프로그램이 더 작은 메모리를 차지하기 때문에 더 많은 프로그램을 동시 수행 가능 (한것처럼 보임...)
3. 프로그램을 메모리에 올리고 swap하는데 필요한 IO횟수가 줄어듬

[출처] [https://www.youtube.com/watch?v=5pEDL6c--_k&t=5s](https://www.youtube.com/watch?v=5pEDL6c--_k&t=5s)
