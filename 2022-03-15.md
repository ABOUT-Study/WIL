# 1
## 대규모 데이터 처리의 어려운점
- 대규모 데이터는 어떤 점이 어려운가?
    - 메모리 내에서 계산할 수 없다.
        - 메모리 내에서 계산하게 된다면 성능이 빠르겠지만, 대규모 데이터들은 너무 많아서 메모리 내에서 계산할 수가 없다. 디스크에 두고 데이터를 검색해야한다.
- 메모리와 디스크의 속도차
    - 디스크는 메모리보다 훨씬 느리다. 10^5 ~ 10^6 정도 차이가 난다.
- 디스크가 늦는 이유
    1. 탐색 속도
        - 디스크는 물리적 구조로 이루어진 장치고 메모리는 전기적인 신호로 동작한다. 물리적인 구조는 한계가 있다.
        - 디스크는 데이터를 읽을 때 헤드의 이동, 디스크의 회전 등의 이유로 탐색 속도가 늦다.
        - 디스크의 느린다는 단점을 OS가 “비슷한 데이터를 한곳에 모아둬서 한번에 많이 읽게한다” 같은 기술로 커버해준다, 그래도 메모리보다 느리다.
    2. 전송 속도
        - 메모리와 디스크 모두  CPU와 버스로 연결되어있다.
        - 탐색한 데이터를 처리하기위해서는 결국엔 CPU로 보내야하는데 이 속도도 메모리가 훨씬 앞선다.
        - 요즘엔 물리적인 SSD가 나와서 탐색 속도는 빨라졌지만, 그래도 메모리에 비해선 훨씬 느리다.

[출처] 대규모 서비스를 지탱하는 기술(강의5)

# 2 
## 대규모 조정의 요소(CPU부하와 I/O부하)
- 규모조정, 확장성
    - 웹 서비스에서 성능을 높이는 일반적인 방법은 **스케일 아웃**이다. 고가의 하드웨어를 사는 스케일업보다 일반적인 성능의 하드웨어를 여러대 나열하는 것이 더 저렴하고 유연성이 크기 때문이다.
- CPU부하와 I/O부하
    - 우리가 서비스를 이용할때 사용되는 애플리케이션 서버는 기본적으로 **CPU부하만 소요**된다.
    - 하지만 서버는 결국 DB의 질의와 결과를 얻어내야하는데 이때는 **I/O부하**가 걸린다.
- CPU부하로 인한 확장, I/O부하로 인한 DB 확장
    - **애플리케이션 서버는 CPU부하만 걸리므로 분산(=스케일 아웃)이 간단하다.** 그 이유는 기본적으로 데이터를 분산해서 갖고 있는 것이 아니고, 어떤 요청이 들어오면 서버들이 동일하게 처리만 하면 되기 때문이다. 따라서 확장을 위해선 동일한 서버의 대수만 늘리면 되는데, 이는 로드밸런서가 해준다.
    - **반면에 I/O부하로 인한 DB서버 분산에는 문제가 있다.** DB를 여러개 확장하면 그 DB들간의 데이터를 어떻게 동기화 할 것인가에 대한 숙제가 생기기 때문이다.
- DB 확장성 확보의 어려움
    - 위에서 설명한 동기화 문제와 더불어 **DB는 디스크를 많이 사용하기때문에 이 또한 성능의 문제**가 될 수 도 있다.
    - 즉, 대규모 환경에서는 I/O 부하를 부담하고 있는 DB서버는 애초에 분산시키기도 어렵고, 디스크 I/O가 많이 발생할 수 있기때문에 더 어려워진다.
    
- 정리
    - CPU 부하의 규모조정은 간단하다
        - 같은 구성의 서버를 늘리고 로드밸런서로 분산
    - I/O 부하의 규모조정은 어렵다
        - DB 동기화와 디스크 접근에 대한 한계

[출처] 대규모 서비스를 지탱하는 기술(강의6)

# 3

# 4

# 5

# 6

# 7

# 8

# 9
