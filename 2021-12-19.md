# 1
## 클러스터링 vs 리플리케이션 vs 샤딩
가장 기본적인 DB 구조는 다음과 같다.

![1](https://user-images.githubusercontent.com/22884224/145668699-ec2f22fc-8773-4462-aee2-572af6a0e362.png)

하지만 위와 같은 모델은 **DB서버가 죽으면 관련된 서비스 전체가 중단된다**. 이를 해결하기 위한 방법으로, 동일한 DB서버를 2개이상 두는 **클러스터링** 이라는 방법이 있다.   

### 클러스터링
- **클러스터링은 두개 이상의 DB서버를 두기 때문에 하나의 DB서버가 죽어도 나머지 한대가 처리하면 된다. 클러스터링은 2가지 방법으로 나뉜다.**

1. **Active - Active Clustering**
    - 서버 하나가 죽어도 다른서버가 그 역할을 **바로 수행** 할 수 있다.
    - 같이 active된 상태기때문에 **CPU와 메모리 이용률을 높일 수 있다.**
    - 저장소를 하나 공유하기 때문에 **병목현상**이 일어날 수 있다.   
![2](https://user-images.githubusercontent.com/22884224/145668423-91781619-17b0-4992-b969-f3544e6afef0.png)

2. **Active - StandBy Clustering**
    - 운영하는데 Active - Active Clustering보다 **적은비용**이 든다
    - 서버가 죽으면 Stand-by가 Active로 전환되는데 시간이 들기 때문에 **그 시간동안 서비스가 중단**된다.   
![3](https://user-images.githubusercontent.com/22884224/145668424-ec97e6f1-41c0-4087-9b17-682d1aefa6fc.png)

> 위와 같은 클러스터링 2가지방법은 공통적으로 여러 DB서버들이 하나의 스토리지를 공유한다. 그렇기때문에 DB스토리지에 문제가 생기면 데이터를 복구할 수 없는 문제가 있다. 그래서 나온 개념이 **레플리케이션** 이다.

### 레플레케이션
- **DBMS시스템(DB서버+DB스토리지)을 여러개 두고 Master와 Slave로 나눠서 동일한 데이터를 처리하는 방법이다.**
- Master DB는 INSERT, UPDATE, DELETE 작업을 하고, Slave DB는 SELECT 작업을 해서 **전체 서버의 부하를 분산 시킬 수 있다**
- 하지만 데이터 자체가 엄청 많으면 Slave DB를 N대로 늘려도 원하는 데이터를 찾는데 많은 시간이 소요되는 단점은 여전히 존재한다. 이때 활용 가능한 것이 **샤딩** 이라는 방법이다.
 
![5](https://user-images.githubusercontent.com/22884224/145668426-ecb0ee40-b552-48ac-b456-46565f0192e6.png)

### 샤딩
- **샤딩은 테이블을 특정 기준으로 나눠서 저장 및 검색하는 것을 말한다. 샤딩의 핵심은 Data를 어떻게 잘 분산 시켜 저장할지, 그리고 어떻게 잘 읽을 것인지에 대한 것이다.**
- **잘 분산 시켜 저장할지에 기준이 되는것이 Shard Key**이다. Shard key를 어떻게 정의하느냐에 따라 데이터를 효율적으로 분산 시킬 수 있다.
- 여러가지 샤딩 방법이 있다.
![11](https://user-images.githubusercontent.com/22884224/145668428-548c11ea-f52e-4561-97b1-3c76e3eecca6.png)

1. **Hash Sharding**
    - Shard의 수만큼 Hash함수를 사용해서 나온 결과에 따라 DB 서버에 저장하는 방법이다.
    - 구현이 간단하는 장점이 있고, DB 서버가 추가되면 Hash함수를 수정해야하므로 확장성이 낮다.
![9](https://user-images.githubusercontent.com/22884224/145668432-e49cbc33-95cd-472a-ad19-d0de28af29cf.png)

2. **Dynamic Sharding**
    - 테이블 형식의 데이터를 바탕으로 샤드를 결정해서 저장하는 방식을 말한다.
    - 로케이터 서비스를 통해 Shard Key를 얻는다.
    - 확장에 유연하다.
    - 로케이터 서비스에 장애가 발생하면 나머지 shard 또한 문제가 발생한다.
![13](https://user-images.githubusercontent.com/22884224/145668436-c81be091-cec6-47f8-811b-a686abb14811.png)
![7](https://user-images.githubusercontent.com/22884224/145668438-7354da69-3aae-4e6a-a855-b777e559ce5e.png)

3. Entity Group, Moduler Sharding, Range Sharding 등이 있다.


[출처] https://jordy-torvalds.tistory.com/94   
[출처] https://sloth.tistory.com/34      
[출처] https://github.com/workhardslave/cs-study/blob/main/Database/NoSql%2C%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81vs%20%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%2C%20DB%EC%83%A4%EB%94%A9.md



# 2
## JWT vs 세션

# 3
## RestTemplate vs WebClient

# 4

# 5

# 6

# 7

# 8

# 9
