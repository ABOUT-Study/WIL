# 1
## 스레드 풀의 적절한 사이즈는?

  - 스레드 풀을 지정해야 하는 이유
    -  지정하지 않으면 신규 스레드를 계속 생성하고 결국 OOM이 발생하게 된다.
    -  스레드 풀 사이즈를 정해서 재사용을 하게 만들어서 시스템의 성능을 높인다.   
       스레드가 생성될 때는 요청이 처리되는 지연 시간이 발생하고 JVM과 OS에 의한 추가적인 처리 과정이 필요하다.   
  
  - 스레드 풀을 지정할때의 주의 사항
    - DB의존적인 작업을 할 경우 onnection Pool size
    - 외부 서비스와의 통신이 있는경우 외부서비스의 성능
    - CPU의 개수 및 성능 (자바 : int numOfCores = Runtime.getRuntime().availableProcessors(); 로 CPU의 개수를 알수 있다.)

  - 스레드의 풀을 정하는 법   
    - 스레드 수 = 사용 가능한 코어 수 * (1+대기 시간/서비스 시간)   
      (역주 -  (대기 시간/서비스 시간)의 값은 block 계수라고도 한다.)
    - worker 스레드는 '요청에 대한 응답을 JSON으로 변환하고 몇 가지 규칙을 실행하는 'microservice’(이하 micro)' 를 호출한다.
      micro의 응답 시간은 50ms, 서비스 시간은 5ms이며 worker 스레드를 실행시키는 프로그램은 듀얼 코어 cpu에서 동작한다고 가정하자.
      이때 적절한 스레드 풀 사이즈는 2 *(1+50/5) = 22가 된다.

[출처] (https://yaaam.tistory.com/m/6)

# 2
## 페이징 성능 개선하기 - No Offset 사용하기(더보기 방식)

  - 페이징의 단점
    - 데이터가 적을떄는 상관이 없지만 데이터가 많아짐에 따라 레코드를 다 읽고 limit으로 잘라야해서 부담이 된다.
    - 인덱스가 걸려있어도 1억건 정도로 데이터가 증가가 되면 부담이 된다.

  - No Offset 으로 구조 변경하기
    - 기존의 페이징은 offset과 limit으로 데이터를 읽었다. 그러면 offset만큼 데이터를 읽어야고 limit으로 잘라야해서 부담이 된다.
      offset이 1억이고 limit이 2면 1억개를 다 읽고 2개를 가져오기 때문에 속도가 느리게 된다.
    - 해결 책으로 offset을 지우고 기본 아이디에 인덱스를 걸어서 id > 1억 limit 2로 변경을 하게 되면 인덱스를 타고 1억번부터 데이터가
      시작이 되고 데이터를 2개를 가져와서 속도면에서 훨씬 좋게 해결이 된다.
    - 실제로 이 방법은 더보기 방법이라 부르고 페이스북 인스타 등 데이터가 많은 영역에서 많이 사용되고 있다.
   
  - 주의사항
    - order by를 id 기준으로 꼭해야한다
    - id는 상수값이면 좋고 유니크해야한다. 보통 PK로 한다.
    - join이 많은 경우 id의 값을 잘 정해야 한다.
    - 적은 데이터가 있다고 가정될때는 페이징을 써도 무방하다
    - 히스토리성는 항상 많은데 이 데이터를 가공할 일이 있을때 더보기 방식으로 사용하면 좋다.

  ![1](https://user-images.githubusercontent.com/20812458/150626267-3fc8fff5-a3c1-404d-9557-58212f01c5d1.png)


[출처] (https://jojoldu.tistory.com/528)

# 3
## 스프링 배치 멀티 쓰레드 병렬처리

  - 멀티쓰레드 혹은 멀티프로세스 주의 사항
    - 멀티쓰레드는 쉽다. : 단일 프로세스라서 쓰레드간 영향이 있어서 쓰레드 늘어나면 성능 저하.
    - 멀티프로세스는 지점별로 mod 해서, 그 결과로 reader 에서 select 하게 변경. 배치job 을 mod 갯수만큼만든다. 장점. 독립프로세스로 실행되니까 제일 빠르다. 비용 증가.

  - 방법
    - 배치를 만들게 되면 job, step 메소드를 만드는데 step에서 메서드 실행 스텝을 정할때 taskExecutor, throttleLimit를 넣어주면 자동으로 병렬로 처리하게 변경이 된다.
  
  - 예제
    ![2](https://user-images.githubusercontent.com/20812458/150626426-9b0af80e-1281-4d25-8e75-84e9c57304ab.png)   
    ![3](https://user-images.githubusercontent.com/20812458/150626437-8e9aee0d-004f-4e0d-8757-06b607363c78.png)
    
  - 옵션
    - throttleLimit: 기본값 4, 생성된 쓰레드들 중에서 몇개르 사용할지 정한다. 즉 작업의 개수
    - corePoolSize: Pool의 기본 사이즈 
    - maxPoolSize: Pool의 최대 사이즈 
    - setWaitForTasksToCompleteOnShutdown: 실행 중인 작업이 완료된 후 애플리케이션을 종료하는 것을 의미.
    - setAwaitTerminationSeconds: setWaitForTasksToCompleteOnShutdown을 true 값을 주고 setAwaitTerminationSeconds 값을 20으로 설정하여 20초 동안 작업을 마저 진행할 시간을 주도록 한다.

  - 주의
    - 보통 throttleLimit, corePoolSize, maxPoolSize 사이즈는 같은 사이즈로 지정한다
    - 스레드의 사이즈를 잘 정해야 한다.

 [출처] (https://jojoldu.tistory.com/493)   
 [출처] (https://github.com/HomoEfficio/dev-tips/blob/master/Java-Spring%20Thread%20Programming%20%EA%B0%84%EB%8B%A8%20%EC%A0%95%EB%A6%AC.md#threadpoolexecutor)   
 [출처] (https://insanelysimple.tistory.com/327)   
 [출처] (https://sooin01.tistory.com/entry/Spring-batch-chunk-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D)   

# 4

# 5

# 6

# 7

# 8

# 9

# 10

# 11

# 12
