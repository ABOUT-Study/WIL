# 1
## 스레드 풀의 적절한 사이즈는?

  - 스레드 풀을 지정해야 하는 이유
    -  지정하지 않으면 신규 스레드를 계속 생성하고 결국 OOM이 발생하게 된다.
    -  스레드 풀 사이즈를 정해서 재사용을 하게 만들어서 시스템의 성능을 높인다.   
       스레드가 생성될 때는 요청이 처리되는 지연 시간이 발생하고 JVM과 OS에 의한 추가적인 처리 과정이 필요하다.   
  
  - 스레드 풀을 지정할때의 주의 사항
    - DB의존적인 작업을 할 경우 onnection Pool size
    - 외부 서비스와의 통신이 있는경우 외부서비스의 성능
    - CPU의 개수 및 성능 (자바 : int numOfCores = Runtime.getRuntime().availableProcessors(); 로 CPU의 개수를 알수 있다.)

  - 스레드의 풀을 정하는 법   
    - 스레드 수 = 사용 가능한 코어 수 * (1+대기 시간/서비스 시간)   
      (역주 -  (대기 시간/서비스 시간)의 값은 block 계수라고도 한다.)
    - worker 스레드는 '요청에 대한 응답을 JSON으로 변환하고 몇 가지 규칙을 실행하는 'microservice’(이하 micro)' 를 호출한다.
      micro의 응답 시간은 50ms, 서비스 시간은 5ms이며 worker 스레드를 실행시키는 프로그램은 듀얼 코어 cpu에서 동작한다고 가정하자.
      이때 적절한 스레드 풀 사이즈는 2 *(1+50/5) = 22가 된다.

[출처] (https://yaaam.tistory.com/m/6)

# 2
## 페이징 성능 개선하기 - No Offset 사용하기(더보기 방식)

  - 페이징의 단점
    - 데이터가 적을떄는 상관이 없지만 데이터가 많아짐에 따라 레코드를 다 읽고 limit으로 잘라야해서 부담이 된다.
    - 인덱스가 걸려있어도 1억건 정도로 데이터가 증가가 되면 부담이 된다.

  - No Offset 으로 구조 변경하기
    - 기존의 페이징은 offset과 limit으로 데이터를 읽었다. 그러면 offset만큼 데이터를 읽어야고 limit으로 잘라야해서 부담이 된다.
      offset이 1억이고 limit이 2면 1억개를 다 읽고 2개를 가져오기 때문에 속도가 느리게 된다.
    - 해결 책으로 offset을 지우고 기본 아이디에 인덱스를 걸어서 id > 1억 limit 2로 변경을 하게 되면 인덱스를 타고 1억번부터 데이터가
      시작이 되고 데이터를 2개를 가져와서 속도면에서 훨씬 좋게 해결이 된다.
    - 실제로 이 방법은 더보기 방법이라 부르고 페이스북 인스타 등 데이터가 많은 영역에서 많이 사용되고 있다.
   
  - 주의사항
    - order by를 id 기준으로 꼭해야한다
    - id는 상수값이면 좋고 유니크해야한다. 보통 PK로 한다.
    - join이 많은 경우 id의 값을 잘 정해야 한다.
    - 적은 데이터가 있다고 가정될때는 페이징을 써도 무방하다
    - 히스토리성는 항상 많은데 이 데이터를 가공할 일이 있을때 더보기 방식으로 사용하면 좋다.

  ![1](https://user-images.githubusercontent.com/20812458/150626267-3fc8fff5-a3c1-404d-9557-58212f01c5d1.png)


[출처] (https://jojoldu.tistory.com/528)

# 3

# 4

# 5

# 6

# 7

# 8

# 9

# 10

# 11

# 12
